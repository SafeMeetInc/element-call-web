import{d as Dr,e as c,g as Or,h as y,l as g,K as se,L as ur,j as M,D as oe,E as w,H as $,T as J,k as v,m as k,n as pe,o as ae,p as Br,q as qr,s as T,r as te,u as dr,v as lr,w as gr,I as L,M as yr,x as G,A as Tr,y as Pr,z as ve,B as Ur,U as Ve,F as z,S as Ne,G as xe,J as ue,N as Ae,O as b,P as _,Q as ie,R as P,V as H,W as K,X as Vr}from"./index-D0clf0IH.js";import{U as m,E as Nr,a as W,C as Le,R,H as Z,D as Fe,b as O,K as xr,c as Ar,d as Lr,S as Fr,e as jr,T as Gr,f as Wr,g as Jr,P as Hr,V as X,h as je,Q as Ge,i as B,j as Qr,k as U,B as N,l as Yr,L as We,O as $r,m as zr,n as Zr,o as Xr,p as Je,q as hr,r as He,s as et,M as rt,t as q,u as Qe,v as V,w as pr,x as vr,y as fr,z as tt,A as qe,F as it,G as nt,I as de,J as st}from"./matrix-sdk-crypto-wasm-0k4Oq6qg.js";var F=function(s){return s.Change="change",s}({}),S=function(s){return s[s.Unsent=1]="Unsent",s[s.Requested=2]="Requested",s[s.Ready=3]="Ready",s[s.Started=4]="Started",s[s.Cancelled=5]="Cancelled",s[s.Done=6]="Done",s}({}),mr=function(s){return s.Cancel="cancel",s.ShowSas="show_sas",s.ShowReciprocateQr="show_reciprocate_qr",s}({}),le=[139,1];function Ye(s){var e,r=new Uint8Array(le.length+s.length+1);r.set(le,0),r.set(s,le.length);for(var t=0,i=0;i<r.length-1;++i)t^=r[i];r[r.length-1]=t;var n=Dr.encode(r);return(e=n.match(/.{1,4}/g))===null||e===void 0?void 0:e.join(" ")}var ot=256;function kr(s,e,r){return fe.apply(this,arguments)}function fe(){return fe=c(function*(s,e,r){var t=arguments.length>3&&arguments[3]!==void 0?arguments[3]:ot;if(!globalThis.crypto.subtle||!TextEncoder)throw new Error("Password-based backup is not available on this platform");var i=yield globalThis.crypto.subtle.importKey("raw",new TextEncoder().encode(s),{name:"PBKDF2"},!1,["deriveBits"]),n=yield globalThis.crypto.subtle.deriveBits({name:"PBKDF2",salt:new TextEncoder().encode(e),iterations:r,hash:"SHA-512"},i,t);return new Uint8Array(n)}),fe.apply(this,arguments)}var ge,$e;function at(){if($e)return ge;$e=1;for(var s=/[\\\"\x00-\x1F]/g,e={},r=0;r<32;++r)e[String.fromCharCode(r)]="\\U"+("0000"+r.toString(16)).slice(-4).toUpperCase();e["\b"]="\\b",e["	"]="\\t",e[`
`]="\\n",e["\f"]="\\f",e["\r"]="\\r",e['"']='\\"',e["\\"]="\\\\";function t(o){return s.lastIndex=0,o.replace(s,function(u){return e[u]})}function i(o){switch(typeof o){case"string":return'"'+t(o)+'"';case"number":return isFinite(o)?o:"null";case"boolean":return o;case"object":return o===null?"null":Array.isArray(o)?n(o):a(o);default:throw new Error("Cannot stringify: "+typeof o)}}function n(o){for(var u="[",d="",l=0;l<o.length;++l)d+=u,u=",",d+=i(o[l]);return u!=","?"[]":d+"]"}function a(o){var u="{",d="",l=Object.keys(o);l.sort();for(var p=0;p<l.length;++p){var h=l[p];d+=u+'"'+t(h)+'":',u=",",d+=i(o[h])}return u!=","?"{}":d+"}"}return ge={stringify:i},ge}var ct=at();const ut=Or(ct);class dt{constructor(e,r,t,i,n){this.olmMachine=e,this.keyClaimManager=r,this.outgoingRequestManager=t,this.room=i,this.encryptionSettings=n,y(this,"prefixedLogger",void 0),y(this,"lazyLoadedMembersResolved",!1),y(this,"currentEncryptionPromise",Promise.resolve()),this.prefixedLogger=g.getChild("[".concat(i.roomId," encryption]"));var a=i.getJoinedMembers();this.olmMachine.updateTrackedUsers(a.map(o=>new m(o.userId))).catch(o=>this.prefixedLogger.error("Error initializing tracked users",o))}onCryptoEvent(e){if(JSON.stringify(this.encryptionSettings)!=JSON.stringify(e))throw new Error("Cannot reconfigure an active RoomEncryptor")}onRoomMembership(e){(e.membership==se.Join||e.membership==se.Invite&&this.room.shouldEncryptForInvitedMembers())&&this.olmMachine.updateTrackedUsers([new m(e.userId)]).catch(r=>{this.prefixedLogger.error("Unable to update tracked users",r)})}prepareForEncryption(e,r){var t=this;return c(function*(){yield t.encryptEvent(null,e,r)})()}encryptEvent(e,r,t){var i,n=this,a=new ur(this.prefixedLogger,e?(i=e.getTxnId())!==null&&i!==void 0?i:"":"prepareForEncryption"),o=this.currentEncryptionPromise.catch(()=>{}).then(c(function*(){yield M(a,"ensureEncryptionSession",c(function*(){yield n.ensureEncryptionSession(a,r,t)})),e&&(yield M(a,"encryptEventInner",c(function*(){yield n.encryptEventInner(a,e)})))}));return this.currentEncryptionPromise=o,o}ensureEncryptionSession(e,r,t){var i=this;return c(function*(){if(i.encryptionSettings.algorithm!=="m.megolm.v1.aes-sha2")throw new Error("Cannot encrypt in ".concat(i.room.roomId," for unsupported algorithm '").concat(i.encryptionSettings.algorithm,"'"));e.debug("Starting encryption");var n=yield i.room.getEncryptionTargetMembers();i.lazyLoadedMembersResolved?(e.debug("Processing outgoing requests in background"),i.outgoingRequestManager.doProcessOutgoingRequests()):(yield M(i.prefixedLogger,"loadMembersIfNeeded: updateTrackedUsers",c(function*(){yield i.olmMachine.updateTrackedUsers(n.map(l=>new m(l.userId)))})),e.debug("Updated tracked users"),i.lazyLoadedMembersResolved=!0,e.debug("Processing outgoing requests"),yield M(i.prefixedLogger,"doProcessOutgoingRequests",c(function*(){yield i.outgoingRequestManager.doProcessOutgoingRequests()}))),e.debug("Encrypting for users (shouldEncryptForInvitedMembers: ".concat(i.room.shouldEncryptForInvitedMembers(),"):"),n.map(l=>"".concat(l.userId," (").concat(l.membership,")")));var a=n.map(l=>new m(l.userId));yield M(i.prefixedLogger,"ensureSessionsForUsers",c(function*(){yield i.keyClaimManager.ensureSessionsForUsers(e,a)}));var o=new Nr;switch(o.historyVisibility=lt(i.room.getHistoryVisibility()),o.algorithm=W.MegolmV1AesSha2,typeof i.encryptionSettings.rotation_period_ms=="number"&&(o.rotationPeriod=BigInt(i.encryptionSettings.rotation_period_ms*1e3)),typeof i.encryptionSettings.rotation_period_msgs=="number"&&(o.rotationPeriodMessages=BigInt(i.encryptionSettings.rotation_period_msgs)),t.kind){case oe.AllDevicesIsolationMode:{var u,d=(u=i.room.getBlacklistUnverifiedDevices())!==null&&u!==void 0?u:r;o.sharingStrategy=Le.deviceBasedStrategy(d,t.errorOnVerifiedUserProblems)}break;case oe.OnlySignedDevicesIsolationMode:o.sharingStrategy=Le.identityBasedStrategy();break}yield M(i.prefixedLogger,"shareRoomKey",c(function*(){var l=yield i.olmMachine.shareRoomKey(new R(i.room.roomId),a,o);if(l)for(var p of l)yield i.outgoingRequestManager.outgoingRequestProcessor.makeOutgoingRequest(p)}))})()}forceDiscardSession(){var e=this;return c(function*(){var r=yield e.olmMachine.invalidateGroupSession(new R(e.room.roomId));r&&e.prefixedLogger.info("Discarded existing group session")})()}encryptEventInner(e,r){var t=this;return c(function*(){e.debug("Encrypting actual message content");var i=yield t.olmMachine.encryptRoomEvent(new R(t.room.roomId),r.getType(),JSON.stringify(r.getContent()));r.makeEncrypted(w.RoomMessageEncrypted,JSON.parse(i),t.olmMachine.identityKeys.curve25519.toBase64(),t.olmMachine.identityKeys.ed25519.toBase64()),e.debug("Encrypted event successfully")})()}}function lt(s){switch(s){case $.Invited:return Z.Invited;case $.Joined:return Z.Joined;case $.Shared:return Z.Shared;case $.WorldReadable:return Z.WorldReadable}}var j="/_matrix/client/unstable/org.matrix.msc3814.v1",ye="org.matrix.msc3814",gt=7*24*60*60*1e3;class yt extends J{constructor(e,r,t,i,n){super(),this.logger=e,this.olmMachine=r,this.http=t,this.outgoingRequestProcessor=i,this.secretStorage=n,y(this,"intervalId",void 0)}cacheKey(e){var r=this;return c(function*(){yield r.olmMachine.dehydratedDevices().saveDehydratedDeviceKey(e),r.emit(v.DehydrationKeyCached)})()}isSupported(){var e=this;return c(function*(){try{yield e.http.authedRequest(k.Get,"/dehydrated_device",void 0,void 0,{prefix:j})}catch(t){var r=t;if(r.errcode==="M_UNRECOGNIZED")return!1;if(r.errcode==="M_NOT_FOUND")return!0;throw t}return!0})()}start(){var e=arguments,r=this;return c(function*(){var t=e.length>0&&e[0]!==void 0?e[0]:{};if(typeof t=="boolean"&&(t={createNewKey:t}),!(t.onlyIfKeyCached&&!(yield r.olmMachine.dehydratedDevices().getDehydratedDeviceKey()))){if(r.stop(),t.rehydrate!==!1)try{yield r.rehydrateDeviceIfAvailable()}catch(i){r.logger.info("dehydration: Error rehydrating device:",i),r.emit(v.RehydrationError,i.message)}t.createNewKey&&(yield r.resetKey()),yield r.scheduleDeviceDehydration()}})()}isKeyStored(){var e=this;return c(function*(){return!!(yield e.secretStorage.isStored(ye))})()}resetKey(){var e=this;return c(function*(){var r=Fe.createRandomKey();return yield e.secretStorage.store(ye,r.toBase64()),yield e.cacheKey(r),r})()}getKey(e){var r=this;return c(function*(){var t=yield r.olmMachine.dehydratedDevices().getDehydratedDeviceKey();if(t)return t;var i=yield r.secretStorage.get(ye);if(i===void 0)return e?yield r.resetKey():null;var n=pe(i);try{var a=Fe.createKeyFromArray(n);return yield r.cacheKey(a),a}finally{n.fill(0)}})()}rehydrateDeviceIfAvailable(){var e=this;return c(function*(){var r=yield e.getKey(!1);if(!r)return!1;var t;try{t=yield e.http.authedRequest(k.Get,"/dehydrated_device",void 0,void 0,{prefix:j})}catch(h){var i=h;if(i.errcode==="M_NOT_FOUND"||i.errcode==="M_UNRECOGNIZED")return e.logger.info("dehydration: No dehydrated device"),!1;throw i}e.logger.info("dehydration: dehydrated device found"),e.emit(v.RehydrationStarted);var n=yield e.olmMachine.dehydratedDevices().rehydrate(r,new O(t.device_id),JSON.stringify(t.device_data));e.logger.info("dehydration: device rehydrated");for(var a=void 0,o=0,u=0,d=ae("/dehydrated_device/$device_id/events",{$device_id:t.device_id});;){var l=yield e.http.authedRequest(k.Post,d,void 0,a?{next_batch:a}:{},{prefix:j});if(l.events.length===0)break;o+=l.events.length,a=l.next_batch;var p=yield n.receiveEvents(JSON.stringify(l.events));u+=p.length,e.emit(v.RehydrationProgress,u,o)}return e.logger.info("dehydration: received ".concat(u," room keys from ").concat(o," to-device events")),e.emit(v.RehydrationCompleted),!0})()}createAndUploadDehydratedDevice(){var e=this;return c(function*(){var r=yield e.getKey(!0),t=yield e.olmMachine.dehydratedDevices().create();e.emit(v.DehydratedDeviceCreated);var i=yield t.keysForUpload("Dehydrated device",r);yield e.outgoingRequestProcessor.makeOutgoingRequest(i),e.emit(v.DehydratedDeviceUploaded),e.logger.info("dehydration: uploaded device")})()}scheduleDeviceDehydration(){var e=this;return c(function*(){e.stop(),yield e.createAndUploadDehydratedDevice(),e.intervalId=setInterval(()=>{e.createAndUploadDehydratedDevice().catch(r=>{e.emit(v.DehydratedDeviceRotationError,r.message),e.logger.error("Error creating dehydrated device:",r)})},gt)})()}stop(){this.intervalId&&(clearInterval(this.intervalId),this.intervalId=void 0)}delete(){var e=this;return c(function*(){e.stop();try{yield e.http.authedRequest(k.Delete,"/dehydrated_device",void 0,{},{prefix:j})}catch(t){var r=t;if(r.errcode==="M_UNRECOGNIZED")return;if(r.errcode==="M_NOT_FOUND")return;throw t}})()}}function ze(s,e){var r=Object.keys(s);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(s);e&&(t=t.filter(function(i){return Object.getOwnPropertyDescriptor(s,i).enumerable})),r.push.apply(r,t)}return r}function ht(s){for(var e=1;e<arguments.length;e++){var r=arguments[e]!=null?arguments[e]:{};e%2?ze(Object(r),!0).forEach(function(t){y(s,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(s,Object.getOwnPropertyDescriptors(r)):ze(Object(r)).forEach(function(t){Object.defineProperty(s,t,Object.getOwnPropertyDescriptor(r,t))})}return s}class pt{constructor(e,r){this.olmMachine=e,this.http=r}makeOutgoingRequest(e,r){var t=this;return c(function*(){var i;if(e instanceof xr)i=yield t.requestWithRetry(k.Post,"/_matrix/client/v3/keys/upload",{},e.body);else if(e instanceof Ar)i=yield t.requestWithRetry(k.Post,"/_matrix/client/v3/keys/query",{},e.body);else if(e instanceof Lr)i=yield t.requestWithRetry(k.Post,"/_matrix/client/v3/keys/claim",{},e.body);else if(e instanceof Fr)i=yield t.requestWithRetry(k.Post,"/_matrix/client/v3/keys/signatures/upload",{},e.body);else if(e instanceof jr)i=yield t.requestWithRetry(k.Put,"/_matrix/client/v3/room_keys/keys",{version:e.version},e.body);else if(e instanceof Gr)i=yield t.sendToDeviceRequest(e);else if(e instanceof Wr){var n="/_matrix/client/v3/rooms/".concat(encodeURIComponent(e.room_id),"/send/")+"".concat(encodeURIComponent(e.event_type),"/").concat(encodeURIComponent(e.txn_id));i=yield t.requestWithRetry(k.Put,n,{},e.body)}else if(e instanceof Jr){yield t.makeRequestWithUIA(k.Post,"/_matrix/client/v3/keys/device_signing/upload",{},e.body,r);return}else if(e instanceof Hr){var a=j+"/dehydrated_device";yield t.rawJsonRequest(k.Put,a,{},e.body);return}else g.warn("Unsupported outgoing message",Object.getPrototypeOf(e)),i="";if(e.id)try{yield M(g,"Mark Request as sent ".concat(e.type),c(function*(){yield t.olmMachine.markRequestAsSent(e.id,e.type,i)}))}catch(o){if(o instanceof Error&&(o.message==="Attempt to use a moved value"||o.message==="null pointer passed to rust"))g.log("Ignoring error '".concat(o.message,"': client is likely shutting down"));else throw o}else g.trace("Outgoing request type:".concat(e.type," does not have an ID"))})()}sendToDeviceRequest(e){var r=this;return c(function*(){var t=JSON.parse(e.body),i=[];for(var[n,a]of Object.entries(t.messages))for(var[o,u]of Object.entries(a))i.push("".concat(n,"/").concat(o," (msgid ").concat(u[Br],")"));g.info("Sending batch of to-device messages. type=".concat(e.event_type," txnid=").concat(e.txn_id),i);var d="/_matrix/client/v3/sendToDevice/".concat(encodeURIComponent(e.event_type),"/")+encodeURIComponent(e.txn_id);return yield r.requestWithRetry(k.Put,d,{},e.body)})()}makeRequestWithUIA(e,r,t,i,n){var a=this;return c(function*(){if(!n)return yield a.requestWithRetry(e,r,t,i);var o=JSON.parse(i),u=function(){var l=c(function*(p){var h=ht({},o);p!==null&&(h.auth=p);var f=yield a.requestWithRetry(e,r,t,JSON.stringify(h));return JSON.parse(f)});return function(h){return l.apply(this,arguments)}}(),d=yield n(u);return JSON.stringify(d)})()}requestWithRetry(e,r,t,i){var n=this;return c(function*(){for(var a=0;;)try{return yield n.rawJsonRequest(e,r,t,i)}catch(u){a++;var o=qr(u,a,!0);if(o<0)throw u;yield T(o)}})()}rawJsonRequest(e,r,t,i){var n=this;return c(function*(){var a={json:!1,headers:{"Content-Type":"application/json",Accept:"application/json"},prefix:"",localTimeoutMs:6e4};return yield n.http.authedRequest(e,r,t,i,a)})()}}class vt{constructor(e,r){this.olmMachine=e,this.outgoingRequestProcessor=r,y(this,"currentClaimPromise",void 0),y(this,"stopped",!1),this.currentClaimPromise=Promise.resolve()}stop(){this.stopped=!0}ensureSessionsForUsers(e,r){var t=this.currentClaimPromise.catch(()=>{}).then(()=>this.ensureSessionsForUsersInner(e,r));return this.currentClaimPromise=t,t}ensureSessionsForUsersInner(e,r){var t=this;return c(function*(){if(t.stopped)throw new Error("Cannot ensure Olm sessions: shutting down");e.info("Checking for missing Olm sessions");var i=yield t.olmMachine.getMissingSessions(r.map(n=>n.clone()));i&&(e.info("Making /keys/claim request"),yield t.outgoingRequestProcessor.makeOutgoingRequest(i)),e.info("Olm sessions prepared")})()}}function ft(s,e){var r=new Map;for(var[t,i]of s.keys.entries())r.set(t.toString(),i.toBase64());var n=te.Unverified;s.isBlacklisted()?n=te.Blocked:s.isVerified()&&(n=te.Verified);var a=new Map,o=s.signatures.get(e);if(o){var u=new Map;for(var[d,l]of o.entries())l.isValid()&&l.signature&&u.set(d,l.signature.toBase64());a.set(e.toString(),u)}var p=s.algorithms,h=new Set;return p.forEach(f=>{switch(f){case W.MegolmV1AesSha2:h.add("m.megolm.v1.aes-sha2");break;case W.OlmV1Curve25519AesSha2:default:h.add("m.olm.v1.curve25519-aes-sha2");break}}),new dr({deviceId:s.deviceId.toString(),userId:e.toString(),keys:r,algorithms:Array.from(h),verified:n,signatures:a,displayName:s.displayName,dehydrated:s.isDehydrated})}function mt(s){return new Map(Object.entries(s).map(e=>{var[r,t]=e;return[r,kt(t)]}))}function kt(s){var e,r=new Map(Object.entries(s.keys)),t=(e=s.unsigned)===null||e===void 0?void 0:e.device_display_name,i=new Map;if(s.signatures)for(var n in s.signatures)i.set(n,new Map(Object.entries(s.signatures[n])));return new dr({deviceId:s.device_id,userId:s.user_id,keys:r,algorithms:s.algorithms,verified:te.Unverified,signatures:i,displayName:t})}class St{constructor(e,r,t){this.olmMachine=e,this.outgoingRequestProcessor=r,this.secretStorage=t}bootstrapCrossSigning(e){var r=this;return c(function*(){if(e.setupNewCrossSigning){yield r.resetCrossSigning(e.authUploadDeviceSigningKeys);return}var t=yield r.olmMachine.crossSigningStatus(),i=yield r.secretStorage.get("m.cross_signing.master"),n=yield r.secretStorage.get("m.cross_signing.self_signing"),a=yield r.secretStorage.get("m.cross_signing.user_signing"),o=!!(i&&n&&a),u=t.hasMaster&&t.hasUserSigning&&t.hasSelfSigning;if(g.log("bootstrapCrossSigning: starting",{setupNewCrossSigning:e.setupNewCrossSigning,olmDeviceHasMaster:t.hasMaster,olmDeviceHasUserSigning:t.hasUserSigning,olmDeviceHasSelfSigning:t.hasSelfSigning,privateKeysInSecretStorage:o}),u)(yield r.secretStorage.hasKey())?o?g.log("bootstrapCrossSigning: Olm device has private keys and they are saved in secret storage; doing nothing"):(g.log("bootstrapCrossSigning: Olm device has private keys: exporting to secret storage"),yield r.exportCrossSigningKeysToStorage()):g.warn("bootstrapCrossSigning: Olm device has private keys, but secret storage is not yet set up; doing nothing for now.");else if(o){g.log("bootstrapCrossSigning: Cross-signing private keys not found locally, but they are available in secret storage, reading storage and caching locally");var d=yield r.olmMachine.importCrossSigningKeys(i,n,a);if(!d.hasMaster||!d.hasSelfSigning||!d.hasUserSigning)throw new Error("importCrossSigningKeys failed to import the keys");var l=yield r.olmMachine.getDevice(r.olmMachine.userId,r.olmMachine.deviceId);try{var p=yield l.verify();yield r.outgoingRequestProcessor.makeOutgoingRequest(p)}finally{l.free()}}else g.log("bootstrapCrossSigning: Cross-signing private keys not found locally or in secret storage, creating new keys"),yield r.resetCrossSigning(e.authUploadDeviceSigningKeys);g.log("bootstrapCrossSigning: complete")})()}resetCrossSigning(e){var r=this;return c(function*(){var t=yield r.olmMachine.bootstrapCrossSigning(!0);(yield r.secretStorage.hasKey())?(g.log("resetCrossSigning: exporting private keys to secret storage"),yield r.exportCrossSigningKeysToStorage()):g.warn("resetCrossSigning: Secret storage is not yet set up; not exporting keys to secret storage yet."),g.log("resetCrossSigning: publishing public keys to server");for(var i of[t.uploadKeysRequest,t.uploadSigningKeysRequest,t.uploadSignaturesRequest])i&&(yield r.outgoingRequestProcessor.makeOutgoingRequest(i,e))})()}exportCrossSigningKeysToStorage(){var e=this;return c(function*(){var r=yield e.olmMachine.exportCrossSigningKeys();r!=null&&r.masterKey?yield e.secretStorage.store("m.cross_signing.master",r.masterKey):g.error("Cannot export MSK to secret storage, private key unknown"),r!=null&&r.self_signing_key?yield e.secretStorage.store("m.cross_signing.self_signing",r.self_signing_key):g.error("Cannot export SSK to secret storage, private key unknown"),r!=null&&r.userSigningKey?yield e.secretStorage.store("m.cross_signing.user_signing",r.userSigningKey):g.error("Cannot export USK to secret storage, private key unknown")})()}}function Ze(s){return me.apply(this,arguments)}function me(){return me=c(function*(s){return Sr(s,["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"])}),me.apply(this,arguments)}function Sr(s,e){return ke.apply(this,arguments)}function ke(){return ke=c(function*(s,e){var r=yield s.getDefaultKeyId();if(!r)return!1;for(var t of e){var i=(yield s.isStored(t))||{};if(!(r in i))return!1}return!0}),ke.apply(this,arguments)}var E=function(s){return s.Sas="m.sas.v1",s.ShowQrCode="m.qr_code.show.v1",s.ScanQrCode="m.qr_code.scan.v1",s.Reciprocate="m.reciprocate.v1",s}({});class _t extends J{constructor(e,r,t,i,n){super(),this.logger=e,this.olmMachine=r,this.inner=t,this.outgoingRequestProcessor=i,this.supportedVerificationMethods=n,y(this,"reEmitter",void 0),y(this,"_accepting",!1),y(this,"_cancelling",!1),y(this,"_verifier",void 0),this.reEmitter=new lr(this);var a=new WeakRef(this);t.registerChangesCallback(c(function*(){var o;return(o=a.deref())===null||o===void 0?void 0:o.onChange()}))}onChange(){var e=this.inner.getVerification();e instanceof je?this._verifier===void 0||this._verifier instanceof Xe?this.setVerifier(new er(e,this,this.outgoingRequestProcessor)):this._verifier instanceof er&&this._verifier.replaceInner(e):e instanceof Ge&&this._verifier===void 0&&this.setVerifier(new Xe(e,this.outgoingRequestProcessor)),this.emit(F.Change)}setVerifier(e){this._verifier&&this.reEmitter.stopReEmitting(this._verifier,[F.Change]),this._verifier=e,this.reEmitter.reEmit(this._verifier,[F.Change])}get transactionId(){return this.inner.flowId}get roomId(){var e;return(e=this.inner.roomId)===null||e===void 0?void 0:e.toString()}get initiatedByMe(){return this.inner.weStarted()}get otherUserId(){return this.inner.otherUserId.toString()}get otherDeviceId(){var e;return(e=this.inner.otherDeviceId)===null||e===void 0?void 0:e.toString()}getOtherDevice(){var e=this;return c(function*(){var r=e.inner.otherDeviceId;if(r)return yield e.olmMachine.getDevice(e.inner.otherUserId,r,5)})()}get isSelfVerification(){return this.inner.isSelfVerification()}get phase(){var e=this.inner.phase();switch(e){case B.Created:case B.Requested:return S.Requested;case B.Ready:return this._accepting?S.Requested:S.Ready;case B.Transitioned:if(!this._verifier)throw new Error("VerificationRequest: inner phase == Transitioned but no verifier!");return this._verifier.verificationPhase;case B.Done:return S.Done;case B.Cancelled:return S.Cancelled}throw new Error("Unknown verification phase ".concat(e))}get pending(){if(this.inner.isPassive())return!1;var e=this.phase;return e!==S.Done&&e!==S.Cancelled}get accepting(){return this._accepting}get declining(){return this._cancelling}get timeout(){return this.inner.timeRemainingMillis()}get methods(){throw new Error("not implemented")}get chosenMethod(){if(this.phase!==S.Started)return null;var e=this.inner.getVerification();return e instanceof je?E.Sas:e instanceof Ge?E.Reciprocate:null}otherPartySupportsMethod(e){var r=this.inner.theirSupportedMethods;if(r===void 0)return!1;var t=br[e];return r.some(i=>i===t)}accept(){var e=this;return c(function*(){if(e.inner.phase()!==B.Requested||e._accepting)throw new Error("Cannot accept a verification request in phase ".concat(e.phase));e._accepting=!0;try{var r=e.inner.acceptWithMethods(e.supportedVerificationMethods.map(ne));r&&(yield e.outgoingRequestProcessor.makeOutgoingRequest(r))}finally{e._accepting=!1}e.emit(F.Change)})()}cancel(e){var r=this;return c(function*(){if(!r._cancelling){r.logger.info("Cancelling verification request with params:",e),r._cancelling=!0;try{var t=r.inner.cancel();t&&(yield r.outgoingRequestProcessor.makeOutgoingRequest(t))}finally{r._cancelling=!1}}})()}beginKeyVerification(e,r){throw new Error("not implemented")}startVerification(e){var r=this;return c(function*(){if(e!==E.Sas)throw new Error("Unsupported verification method ".concat(e));if(!(yield r.getOtherDevice()))throw new Error("startVerification(): other device is unknown");var t=yield r.inner.startSas();if(t){var[,i]=t;yield r.outgoingRequestProcessor.makeOutgoingRequest(i)}if(!r._verifier)throw new Error("Still no verifier after startSas() call");return r._verifier})()}scanQRCode(e){var r=this;return c(function*(){var t=Qr.fromBytes(e),i=yield r.inner.scanQrCode(t);if(!r._verifier)throw new Error("Still no verifier after scanQrCode() call");var n=i.reciprocate();return n&&(yield r.outgoingRequestProcessor.makeOutgoingRequest(n)),r._verifier})()}get verifier(){return this.phase===S.Started?this._verifier:void 0}getQRCodeBytes(){throw new Error("getQRCodeBytes() unsupported in Rust Crypto; use generateQRCode() instead.")}generateQRCode(){var e=this;return c(function*(){if(!(yield e.getOtherDevice()))throw new Error("generateQRCode(): other device is unknown");var r=yield e.inner.generateQrCode();if(r)return r.toBytes()})()}get cancellationCode(){var e,r;return(e=(r=this.inner.cancelInfo)===null||r===void 0?void 0:r.cancelCode())!==null&&e!==void 0?e:null}get cancellingUserId(){var e=this.inner.cancelInfo;if(e)return e.cancelledbyUs()?this.olmMachine.userId.toString():this.inner.otherUserId.toString()}}class _r extends J{constructor(e,r){super(),this.inner=e,this.outgoingRequestProcessor=r,y(this,"completionDeferred",void 0),this.completionDeferred=Promise.withResolvers();var t=new WeakRef(this);e.registerChangesCallback(c(function*(){var i;return(i=t.deref())===null||i===void 0?void 0:i.onChange()})),this.completionDeferred.promise.catch(()=>null)}onChange(){if(this.inner.isDone())this.completionDeferred.resolve(void 0);else if(this.inner.isCancelled()){var e=this.inner.cancelInfo();this.completionDeferred.reject(new Error("Verification cancelled by ".concat(e.cancelledbyUs()?"us":"them"," with code ").concat(e.cancelCode(),": ").concat(e.reason())))}this.emit(F.Change)}get hasBeenCancelled(){return this.inner.isCancelled()}get userId(){return this.inner.otherUserId.toString()}cancel(e){var r=this.inner.cancel();r&&this.outgoingRequestProcessor.makeOutgoingRequest(r)}getShowSasCallbacks(){return null}getReciprocateQrCodeCallbacks(){return null}}class Xe extends _r{constructor(e,r){super(e,r),y(this,"callbacks",null)}onChange(){this.callbacks===null&&this.inner.hasBeenScanned()&&(this.callbacks={confirm:()=>{this.confirmScanning()},cancel:()=>this.cancel()}),super.onChange()}verify(){var e=this;return c(function*(){e.callbacks!==null&&e.emit(mr.ShowReciprocateQr,e.callbacks),yield e.completionDeferred.promise})()}get verificationPhase(){switch(this.inner.state()){case U.Created:return S.Ready;case U.Scanned:return S.Started;case U.Confirmed:return S.Started;case U.Reciprocated:return S.Started;case U.Done:return S.Done;case U.Cancelled:return S.Cancelled;default:throw new Error("Unknown qr code state ".concat(this.inner.state()))}}getReciprocateQrCodeCallbacks(){return this.callbacks}confirmScanning(){var e=this;return c(function*(){var r=e.inner.confirmScanning();r&&(yield e.outgoingRequestProcessor.makeOutgoingRequest(r))})()}}class er extends _r{constructor(e,r,t){super(e,t),y(this,"callbacks",null)}verify(){var e=this;return c(function*(){yield e.sendAccept(),yield e.completionDeferred.promise})()}sendAccept(){var e=this;return c(function*(){var r=e.inner.accept();r&&(yield e.outgoingRequestProcessor.makeOutgoingRequest(r))})()}onChange(){var e=this;if(super.onChange(),this.callbacks===null){var r=this.inner.emoji(),t=this.inner.decimals();if(r===void 0&&t===void 0)return;var i={};r&&(i.emoji=r.map(n=>[n.symbol,n.description])),t&&(i.decimal=[t[0],t[1],t[2]]),this.callbacks={sas:i,confirm:function(){var n=c(function*(){var o=yield e.inner.confirm();for(var u of o)yield e.outgoingRequestProcessor.makeOutgoingRequest(u)});function a(){return n.apply(this,arguments)}return a}(),mismatch:()=>{var n=this.inner.cancelWithCode("m.mismatched_sas");n&&this.outgoingRequestProcessor.makeOutgoingRequest(n)},cancel:()=>{var n=this.inner.cancelWithCode("m.user");n&&this.outgoingRequestProcessor.makeOutgoingRequest(n)}},this.emit(mr.ShowSas,this.callbacks)}}get verificationPhase(){return S.Started}getShowSasCallbacks(){return this.callbacks}replaceInner(e){if(this.inner!=e){this.inner=e;var r=new WeakRef(this);e.registerChangesCallback(c(function*(){var t;return(t=r.deref())===null||t===void 0?void 0:t.onChange()})),this.sendAccept(),this.onChange()}}}var br={[E.Sas]:X.SasV1,[E.ScanQrCode]:X.QrCodeScanV1,[E.ShowQrCode]:X.QrCodeShowV1,[E.Reciprocate]:X.ReciprocateV1};function ne(s){var e=br[s];if(e===void 0)throw new Error("Unknown verification method ".concat(s));return e}function bt(s){switch(s.getType()){case w.KeyVerificationCancel:case w.KeyVerificationDone:case w.KeyVerificationMac:case w.KeyVerificationStart:case w.KeyVerificationKey:case w.KeyVerificationReady:case w.KeyVerificationAccept:return!0;case w.RoomMessage:return s.getContent().msgtype===gr.KeyVerificationRequest;default:return!1}}class wt extends J{constructor(e,r,t){super(),this.olmMachine=e,this.http=r,this.outgoingRequestProcessor=t,y(this,"checkedForBackup",!1),y(this,"serverBackupInfo",void 0),y(this,"activeBackupVersion",null),y(this,"stopped",!1),y(this,"backupKeysLoopRunning",!1),y(this,"keyBackupCheckInProgress",null)}stop(){this.stopped=!0}getActiveBackupVersion(){var e=this;return c(function*(){return(yield e.olmMachine.isBackupEnabled())?e.activeBackupVersion:null})()}getServerBackupInfo(){var e=this;return c(function*(){return yield e.checkKeyBackupAndEnable(!1),e.serverBackupInfo})()}isKeyBackupTrusted(e){var r=this;return c(function*(){var t=yield r.olmMachine.verifyBackup(e),i=yield r.olmMachine.getBackupKeys(),n=i==null?void 0:i.decryptionKey,a=!!n&&rr(e,n);return{matchesDecryptionKey:a,trusted:t.trusted()}})()}checkKeyBackupAndEnable(e){return!e&&this.checkedForBackup?Promise.resolve(null):(this.keyBackupCheckInProgress||(this.keyBackupCheckInProgress=this.doCheckKeyBackup().finally(()=>{this.keyBackupCheckInProgress=null})),this.keyBackupCheckInProgress)}handleBackupSecretReceived(e){var r=this;return c(function*(){var t,i;try{i=yield r.requestKeyBackupVersion()}catch(o){return g.warn("handleBackupSecretReceived: Error checking for latest key backup",o),!1}if(!((t=i)!==null&&t!==void 0&&t.version))return g.warn("handleBackupSecretReceived: Received a backup decryption key, but there is no trusted server-side key backup"),!1;try{var n=N.fromBase64(e),a=rr(i,n);return a?(g.info("handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache."),yield r.saveBackupDecryptionKey(n,i.version),!0):(g.warn("handleBackupSecretReceived: Private decryption key does not match the public key of the current remote backup."),!1)}catch(o){g.warn("handleBackupSecretReceived: Invalid backup decryption key",o)}return!1})()}saveBackupDecryptionKey(e,r){var t=this;return c(function*(){yield t.olmMachine.saveBackupDecryptionKey(e,r),t.emit(v.KeyBackupDecryptionKeyCached,r)})()}importRoomKeys(e,r){var t=this;return c(function*(){yield t.importRoomKeysAsJson(JSON.stringify(e),r)})()}importRoomKeysAsJson(e,r){var t=this;return c(function*(){yield t.olmMachine.importExportedRoomKeys(e,(i,n)=>{var a,o={total:Number(n),successes:Number(i),stage:L.LoadKeys,failures:0};r==null||(a=r.progressCallback)===null||a===void 0||a.call(r,o)})})()}importBackedUpRoomKeys(e,r,t){var i=this;return c(function*(){var n=new Map;for(var a of e){var o=new R(a.room_id);n.has(o)||n.set(o,new Map),n.get(o).set(a.session_id,a)}yield i.olmMachine.importBackedUpRoomKeys(n,(u,d,l)=>{var p,h={total:Number(d),successes:Number(u),stage:L.LoadKeys,failures:Number(l)};t==null||(p=t.progressCallback)===null||p===void 0||p.call(t,h)},r)})()}doCheckKeyBackup(){var e=this;return c(function*(){g.log("Checking key backup status...");var r;try{r=yield e.requestKeyBackupVersion()}catch(n){return g.warn("Error checking for active key backup",n),e.serverBackupInfo=void 0,null}e.checkedForBackup=!0,r&&!r.version&&(g.warn("active backup lacks a useful 'version'; ignoring it"),r=void 0),e.serverBackupInfo=r;var t=yield e.getActiveBackupVersion();if(!r)return t!==null?(g.log("No key backup present on server: disabling key backup"),yield e.disableKeyBackup()):g.log("No key backup present on server: not enabling key backup"),null;var i=yield e.isKeyBackupTrusted(r);return!i.matchesDecryptionKey&&!i.trusted?t!==null?(g.log("Key backup present on server but not trusted: disabling key backup"),yield e.disableKeyBackup()):g.log("Key backup present on server but not trusted: not enabling key backup"):t===null?(g.log("Found usable key backup v".concat(r.version,": enabling key backups")),yield e.enableKeyBackup(r)):t!==r.version?(g.log("On backup version ".concat(t," but found version ").concat(r.version,": switching.")),yield e.disableKeyBackup(),yield e.enableKeyBackup(r)):g.log("Backup version ".concat(r.version," still current")),{backupInfo:r,trustInfo:i}})()}enableKeyBackup(e){var r=this;return c(function*(){yield r.olmMachine.enableBackupV1(e.auth_data.public_key,e.version),r.activeBackupVersion=e.version,r.emit(v.KeyBackupStatus,!0),r.backupKeysLoop()})()}maybeUploadKey(){var e=this;return c(function*(){e.activeBackupVersion!=null&&e.backupKeysLoop()})()}disableKeyBackup(){var e=this;return c(function*(){yield e.olmMachine.disableBackup(),e.activeBackupVersion=null,e.emit(v.KeyBackupStatus,!1)})()}backupKeysLoop(){var e=arguments,r=this;return c(function*(){var t=e.length>0&&e[0]!==void 0?e[0]:1e4;if(r.backupKeysLoopRunning){g.log("Backup loop already running");return}r.backupKeysLoopRunning=!0,g.log("Backup: Starting keys upload loop for backup version:".concat(r.activeBackupVersion,"."));var i=Math.random()*t;yield T(i);try{for(var n=0,a=null,o=!0;!r.stopped;){var u=void 0;try{u=yield M(g,"BackupRoomKeys: Get keys to backup from rust crypto-sdk",c(function*(){return yield r.olmMachine.backupRoomKeys()}))}catch(f){g.error("Backup: Failed to get keys to backup from rust crypto-sdk",f)}if(!u||r.stopped||!r.activeBackupVersion){g.log("Backup: Ending loop for version ".concat(r.activeBackupVersion,".")),u||r.emit(v.KeyBackupSessionsRemaining,0);return}try{if(yield r.outgoingRequestProcessor.makeOutgoingRequest(u),n=0,r.stopped)break;if(!o&&a===null)try{var d=yield r.olmMachine.roomKeyCounts();a=d.total-d.backedUp}catch(f){g.error("Backup: Failed to get key counts from rust crypto-sdk",f)}if(a!==null){r.emit(v.KeyBackupSessionsRemaining,a);var l=r.keysCountInBatch(u);a=Math.max(a-l,0)}}catch(f){if(n++,g.error("Backup: Error processing backup request for rust crypto-sdk",f),f instanceof yr){var p=f.data.errcode;if(p=="M_NOT_FOUND"||p=="M_WRONG_ROOM_KEYS_VERSION"){g.log("Backup: Failed to upload keys to current vesion: ".concat(p,"."));try{yield r.disableKeyBackup()}catch(C){g.error("Backup: An error occurred while disabling key backup:",C)}r.emit(v.KeyBackupFailed,f.data.errcode),r.backupKeysLoopRunning=!1,r.checkKeyBackupAndEnable(!0);return}else if(f.isRateLimitError())try{var h=f.getRetryAfterMs();if(h&&h>0){yield T(h);continue}}catch(C){g.warn("Backup: An error occurred while retrieving a rate-limit retry delay",C)}}yield T(1e3*Math.pow(2,Math.min(n-1,4)))}o=!1}}finally{r.backupKeysLoopRunning=!1}})()}keysCountInBatch(e){var r=JSON.parse(e.body);return tr(r)}requestKeyBackupVersion(e){var r=this;return c(function*(){return yield wr(r.http,e)})()}setupKeyBackup(e){var r=this;return c(function*(){yield r.deleteAllKeyBackupVersions();var t=N.createRandomKey(),i=t.megolmV1PublicKey,n={public_key:i.publicKeyBase64};yield e(n);var a=yield r.http.authedRequest(k.Post,"/room_keys/version",void 0,{algorithm:i.algorithm,auth_data:n},{prefix:G.V3});return yield r.saveBackupDecryptionKey(t,a.version),{version:a.version,algorithm:i.algorithm,authData:n,decryptionKey:t}})()}deleteAllKeyBackupVersions(){var e=this;return c(function*(){for(var r,t,i=(r=(t=yield e.requestKeyBackupVersion())===null||t===void 0?void 0:t.version)!==null&&r!==void 0?r:null;i!=null;){var n,a;yield e.deleteKeyBackupVersion(i),i=(n=(a=yield e.requestKeyBackupVersion())===null||a===void 0?void 0:a.version)!==null&&n!==void 0?n:null}})()}deleteKeyBackupVersion(e){var r=this;return c(function*(){g.debug("deleteKeyBackupVersion v:".concat(e));var t=ae("/room_keys/version/$version",{$version:e});yield r.http.authedRequest(k.Delete,t,void 0,void 0,{prefix:G.V3}),r.activeBackupVersion===e&&(r.serverBackupInfo=null,yield r.disableKeyBackup())})()}createBackupDecryptor(e){return new Rt(e)}restoreKeyBackup(e,r,t){var i=this;return c(function*(){var n=yield i.downloadKeyBackup(e);return i.importKeyBackup(n,e,r,t)})()}downloadKeyBackup(e){return this.http.authedRequest(k.Get,"/room_keys/keys",{version:e},void 0,{prefix:G.V3})}importKeyBackup(e,r,t,i){var n=this;return c(function*(){var a,o=200,u=tr(e),d=0,l=0;i==null||(a=i.progressCallback)===null||a===void 0||a.call(i,{total:u,successes:d,stage:L.LoadKeys,failures:l});var p=function(){var Er=c(function*(ce){var Q,Y=[],Mr=function*(Pe){var Ir=yield t.decryptSessions(ce.get(Pe));Ir.forEach(Ue=>{Ue.room_id=Pe,Y.push(Ue)})};for(var Cr of ce.keys())yield*Mr(Cr);try{yield n.importBackedUpRoomKeys(Y,r),d+=Y.length}catch(Te){l+=Y.length,g.error("Error importing keys from backup",Te)}i==null||(Q=i.progressCallback)===null||Q===void 0||Q.call(i,{total:u,successes:d,stage:L.LoadKeys,failures:l})});return function(Q){return Er.apply(this,arguments)}}(),h=0,f=new Map;for(var[C,I]of Object.entries(e.rooms))if(I.sessions){f.set(C,{});for(var[x,Rr]of Object.entries(I.sessions)){var Kr=f.get(C);Kr[x]=Rr,h+=1,h>=o&&(yield p(f),f=new Map,f.set(C,{}),h=0)}}return h>0&&(yield p(f)),{total:u,imported:d}})()}}function rr(s,e){var r;return s.algorithm!=="m.megolm_backup.v1.curve25519-aes-sha2"?(g.warn("backupMatchesPrivateKey: Unsupported backup algorithm",s.algorithm),!1):((r=s.auth_data)===null||r===void 0?void 0:r.public_key)===e.megolmV1PublicKey.publicKeyBase64}class Rt{constructor(e){y(this,"decryptionKey",void 0),y(this,"sourceTrusted",void 0),this.decryptionKey=e,this.sourceTrusted=!1}decryptSessions(e){var r=this;return c(function*(){var t=[];for(var[i,n]of Object.entries(e))try{var a=JSON.parse(r.decryptionKey.decryptV1(n.session_data.ephemeral,n.session_data.mac,n.session_data.ciphertext));a.session_id=i,t.push(a)}catch(o){g.log("Failed to decrypt megolm session from backup",o,n)}return t})()}free(){this.decryptionKey.free()}}function wr(s,e){return Se.apply(this,arguments)}function Se(){return Se=c(function*(s,e){try{var r=e?ae("/room_keys/version/$version",{$version:e}):"/room_keys/version";return yield s.authedRequest(k.Get,r,void 0,void 0,{prefix:G.V3})}catch(t){if(t.errcode==="M_NOT_FOUND")return null;throw t}}),Se.apply(this,arguments)}function he(s,e){var r=e.auth_data;return r.public_key===s.megolmV1PublicKey.publicKeyBase64}function tr(s){var e=0;for(var{sessions:r}of Object.values(s.rooms))e+=Object.keys(r).length;return e}class Kt{constructor(e,r,t){this.logger=e,this.olmMachine=r,this.outgoingRequestProcessor=t,y(this,"stopped",!1),y(this,"outgoingRequestLoopRunning",!1),y(this,"nextLoopDeferred",void 0)}stop(){this.stopped=!0}doProcessOutgoingRequests(){this.nextLoopDeferred||(this.nextLoopDeferred=Promise.withResolvers());var e=this.nextLoopDeferred.promise;return this.outgoingRequestLoopRunning||this.outgoingRequestLoop().catch(r=>{this.logger.error("Uncaught error in outgoing request loop",r)}),e}outgoingRequestLoop(){var e=this;return c(function*(){if(e.outgoingRequestLoopRunning)throw new Error("Cannot run two outgoing request loops");e.outgoingRequestLoopRunning=!0;try{for(;!e.stopped&&e.nextLoopDeferred;){var r=e.nextLoopDeferred;e.nextLoopDeferred=void 0,yield e.processOutgoingRequests().then(r.resolve,r.reject)}}finally{e.outgoingRequestLoopRunning=!1}e.nextLoopDeferred&&e.nextLoopDeferred.reject(new Error("OutgoingRequestsManager was stopped"))})()}processOutgoingRequests(){var e=this;return c(function*(){if(!e.stopped){var r=yield e.olmMachine.outgoingRequests(),t=function*(o){if(e.stopped)return{v:void 0};try{yield M(e.logger,"Make outgoing request ".concat(o.type),c(function*(){yield e.outgoingRequestProcessor.makeOutgoingRequest(o)}))}catch(u){e.logger.error("Failed to process outgoing request ".concat(o.type,": ").concat(u))}},i;for(var n of r)if(i=yield*t(n),i)return i.v}})()}}var ee=5e3,D=function(s){return s.MISSING_DECRYPTION_KEY="MISSING_DECRYPTION_KEY",s.NETWORK_ERROR="NETWORK_ERROR",s.STOPPED="STOPPED",s}(D||{});class A extends Error{constructor(e){super("Failed to get key from backup: ".concat(e)),this.code=e,this.name="KeyDownloadError"}}class ir extends Error{constructor(e){super("Failed to get key from backup: rate limited"),this.retryMillis=e,this.name="KeyDownloadRateLimitError"}}class Et{constructor(e,r,t,i){this.olmMachine=r,this.http=t,this.backupManager=i,y(this,"stopped",!1),y(this,"configuration",null),y(this,"sessionLastCheckAttemptedTime",new Map),y(this,"logger",void 0),y(this,"downloadLoopRunning",!1),y(this,"queuedRequests",[]),y(this,"hasConfigurationProblem",!1),y(this,"currentBackupVersionCheck",null),y(this,"onBackupStatusChanged",()=>{this.hasConfigurationProblem=!1,this.configuration=null,this.getOrCreateBackupConfiguration().then(n=>{n&&this.downloadKeysLoop()})}),this.logger=e.getChild("[PerSessionKeyBackupDownloader]"),i.on(v.KeyBackupStatus,this.onBackupStatusChanged),i.on(v.KeyBackupFailed,this.onBackupStatusChanged),i.on(v.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isKeyBackupDownloadConfigured(){return this.configuration!==null}getServerBackupInfo(){var e=this;return c(function*(){return yield e.backupManager.getServerBackupInfo()})()}onDecryptionKeyMissingError(e,r){if(this.isAlreadyInQueue(e,r)){this.logger.trace("Not checking key backup for session ".concat(r," as it is already queued"));return}if(this.wasRequestedRecently(r)){this.logger.trace("Not checking key backup for session ".concat(r," as it was already requested recently"));return}this.queuedRequests.push({roomId:e,megolmSessionId:r}),this.downloadKeysLoop()}stop(){this.stopped=!0,this.backupManager.off(v.KeyBackupStatus,this.onBackupStatusChanged),this.backupManager.off(v.KeyBackupFailed,this.onBackupStatusChanged),this.backupManager.off(v.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isAlreadyInQueue(e,r){return this.queuedRequests.some(t=>t.roomId==e&&t.megolmSessionId==r)}markAsNotFoundInBackup(e){var r=Date.now();this.sessionLastCheckAttemptedTime.set(e,r),this.sessionLastCheckAttemptedTime.size>100&&(this.sessionLastCheckAttemptedTime=new Map(Array.from(this.sessionLastCheckAttemptedTime).filter((t,i)=>Math.max(r-i,0)<ee)))}wasRequestedRecently(e){var r=this.sessionLastCheckAttemptedTime.get(e);return r?Math.max(Date.now()-r,0)<ee:!1}getBackupDecryptionKey(){var e=this;return c(function*(){try{return yield e.olmMachine.getBackupKeys()}catch{return null}})()}requestRoomKeyFromBackup(e,r,t){var i=this;return c(function*(){var n=ae("/room_keys/keys/$roomId/$sessionId",{$roomId:r,$sessionId:t});return yield i.http.authedRequest(k.Get,n,{version:e},void 0,{prefix:G.V3})})()}downloadKeysLoop(){var e=this;return c(function*(){if(!e.downloadLoopRunning&&!e.hasConfigurationProblem){e.downloadLoopRunning=!0;try{for(;e.queuedRequests.length>0;){var r=e.queuedRequests[0];try{var t=yield e.getOrCreateBackupConfiguration();if(!t){e.downloadLoopRunning=!1;return}var i=yield e.queryKeyBackup(r.roomId,r.megolmSessionId,t);if(e.stopped)return;try{yield e.decryptAndImport(r,i,t)}catch(n){e.logger.error("Error while decrypting and importing key backup for session ".concat(r.megolmSessionId),n)}e.queuedRequests.shift()}catch(n){if(n instanceof A)switch(n.code){case D.MISSING_DECRYPTION_KEY:e.markAsNotFoundInBackup(r.megolmSessionId),e.queuedRequests.shift();break;case D.NETWORK_ERROR:yield T(ee);break;case D.STOPPED:e.downloadLoopRunning=!1;return}else n instanceof ir&&(yield T(n.retryMillis))}}}finally{e.downloadLoopRunning=!1}}})()}queryKeyBackup(e,r,t){var i=this;return c(function*(){if(i.logger.debug("Checking key backup for session ".concat(r)),i.stopped)throw new A(D.STOPPED);try{var n=yield i.requestRoomKeyFromBackup(t.backupVersion,e,r);return i.logger.debug("Got key from backup for sessionId:".concat(r)),n}catch(d){if(i.stopped)throw new A(D.STOPPED);if(i.logger.info("No luck requesting key backup for session ".concat(r,": ").concat(d)),d instanceof yr){var a=d.data.errcode;if(a=="M_NOT_FOUND")throw new A(D.MISSING_DECRYPTION_KEY);if(d.isRateLimitError()){var o;try{var u;o=(u=d.getRetryAfterMs())!==null&&u!==void 0?u:void 0}catch(l){i.logger.warn("Error while retrieving a rate-limit retry delay",l)}throw o&&o>0&&i.logger.info("Rate limited by server, waiting ".concat(o,"ms")),new ir(o??ee)}}throw new A(D.NETWORK_ERROR)}})()}decryptAndImport(e,r,t){var i=this;return c(function*(){var n={[e.megolmSessionId]:r},a=yield t.decryptor.decryptSessions(n);for(var o of a)o.room_id=e.roomId;yield i.backupManager.importBackedUpRoomKeys(a,t.backupVersion)})()}getOrCreateBackupConfiguration(){var e=this;return c(function*(){if(e.configuration)return e.configuration;if(e.hasConfigurationProblem)return null;if(e.currentBackupVersionCheck!=null)return e.logger.debug("Already checking server version, use current promise"),yield e.currentBackupVersionCheck;e.currentBackupVersionCheck=e.internalCheckFromServer();try{return yield e.currentBackupVersionCheck}finally{e.currentBackupVersionCheck=null}})()}internalCheckFromServer(){var e=this;return c(function*(){var r,t,i,n=null;try{n=yield e.backupManager.getServerBackupInfo()}catch(p){return e.logger.debug("Backup: error while checking server version: ".concat(p)),e.hasConfigurationProblem=!0,null}if(e.logger.debug("Got current backup version from server: ".concat((r=n)===null||r===void 0?void 0:r.version)),((t=n)===null||t===void 0?void 0:t.algorithm)!="m.megolm_backup.v1.curve25519-aes-sha2"){var a;return e.logger.info("Unsupported algorithm ".concat((a=n)===null||a===void 0?void 0:a.algorithm)),e.hasConfigurationProblem=!0,null}if(!((i=n)!==null&&i!==void 0&&i.version))return e.logger.info("No current key backup"),e.hasConfigurationProblem=!0,null;var o=yield e.backupManager.getActiveBackupVersion();if(o==null||n.version!=o)return e.logger.info("The current backup version on the server (".concat(n.version,") is not trusted. Version we are currently backing up to: ").concat(o)),e.hasConfigurationProblem=!0,null;var u=yield e.getBackupDecryptionKey();if(!(u!=null&&u.decryptionKey))return e.logger.debug("Not checking key backup for session (no decryption key)"),e.hasConfigurationProblem=!0,null;if(o!=u.backupVersion)return e.logger.debug("Version for which we have a decryption key (".concat(u.backupVersion,") doesn't match the version we are backing up to (").concat(o,")")),e.hasConfigurationProblem=!0,null;var d=n.auth_data;if(d.public_key!=u.decryptionKey.megolmV1PublicKey.publicKeyBase64)return e.logger.debug("Key backup on server does not match our decryption key"),e.hasConfigurationProblem=!0,null;var l=e.backupManager.createBackupDecryptor(u.decryptionKey);return e.hasConfigurationProblem=!1,e.configuration={decryptor:l,backupVersion:o},e.configuration})()}}function Mt(s,e){if(!s.private_key_salt||!s.private_key_iterations)throw new Error("Salt and/or iterations not found: this backup cannot be restored with a passphrase");return kr(e,s.private_key_salt,s.private_key_iterations,s.private_key_bits)}function nr(s,e){var r=Object.keys(s);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(s);e&&(t=t.filter(function(i){return Object.getOwnPropertyDescriptor(s,i).enumerable})),r.push.apply(r,t)}return r}function sr(s){for(var e=1;e<arguments.length;e++){var r=arguments[e]!=null?arguments[e]:{};e%2?nr(Object(r),!0).forEach(function(t){y(s,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(s,Object.getOwnPropertyDescriptors(r)):nr(Object(r)).forEach(function(t){Object.defineProperty(s,t,Object.getOwnPropertyDescriptor(r,t))})}return s}var or=[E.Sas,E.ScanQrCode,E.ShowQrCode,E.Reciprocate];class Ct extends J{constructor(e,r,t,i,n,a,o){super(),this.logger=e,this.olmMachine=r,this.http=t,this.userId=i,this.secretStorage=a,this.cryptoCallbacks=o,y(this,"RECOVERY_KEY_DERIVATION_ITERATIONS",5e5),y(this,"_trustCrossSignedDevices",!0),y(this,"deviceIsolationMode",new Tr(!1)),y(this,"stopped",!1),y(this,"roomEncryptors",{}),y(this,"eventDecryptor",void 0),y(this,"keyClaimManager",void 0),y(this,"outgoingRequestProcessor",void 0),y(this,"crossSigningIdentity",void 0),y(this,"backupManager",void 0),y(this,"outgoingRequestsManager",void 0),y(this,"perSessionBackupDownloader",void 0),y(this,"dehydratedDeviceManager",void 0),y(this,"reemitter",new lr(this)),y(this,"globalBlacklistUnverifiedDevices",!1),y(this,"_supportedVerificationMethods",or),this.outgoingRequestProcessor=new pt(r,t),this.outgoingRequestsManager=new Kt(this.logger,r,this.outgoingRequestProcessor),this.keyClaimManager=new vt(r,this.outgoingRequestProcessor),this.backupManager=new wt(r,t,this.outgoingRequestProcessor),this.perSessionBackupDownloader=new Et(this.logger,this.olmMachine,this.http,this.backupManager),this.dehydratedDeviceManager=new yt(this.logger,r,t,this.outgoingRequestProcessor,a),this.eventDecryptor=new It(this.logger,r,this.perSessionBackupDownloader),this.reemitter.reEmit(this.backupManager,[v.KeyBackupStatus,v.KeyBackupSessionsRemaining,v.KeyBackupFailed,v.KeyBackupDecryptionKeyCached]),this.reemitter.reEmit(this.dehydratedDeviceManager,[v.DehydratedDeviceCreated,v.DehydratedDeviceUploaded,v.RehydrationStarted,v.RehydrationProgress,v.RehydrationCompleted,v.RehydrationError,v.DehydrationKeyCached,v.DehydratedDeviceRotationError]),this.crossSigningIdentity=new St(r,this.outgoingRequestProcessor,a),this.checkKeyBackupAndEnable()}getOlmMachineOrThrow(){if(this.stopped)throw new Pr;return this.olmMachine}set globalErrorOnUnknownDevices(e){}get globalErrorOnUnknownDevices(){return!1}stop(){this.stopped||(this.stopped=!0,this.keyClaimManager.stop(),this.backupManager.stop(),this.outgoingRequestsManager.stop(),this.perSessionBackupDownloader.stop(),this.dehydratedDeviceManager.stop(),this.olmMachine.close())}encryptEvent(e,r){var t=this;return c(function*(){var i=e.getRoomId(),n=t.roomEncryptors[i];if(!n)throw new Error("Cannot encrypt event in unconfigured room ".concat(i));yield n.encryptEvent(e,t.globalBlacklistUnverifiedDevices,t.deviceIsolationMode)})()}decryptEvent(e){var r=this;return c(function*(){var t=e.getRoomId();if(!t)throw new Error("to-device event was not decrypted in preprocessToDeviceMessages");return yield r.eventDecryptor.attemptEventDecryption(e,r.deviceIsolationMode)})()}getBackupDecryptor(e,r){var t=this;return c(function*(){if(!(r instanceof Uint8Array))throw new Error("getBackupDecryptor: expects Uint8Array");if(e.algorithm!="m.megolm_backup.v1.curve25519-aes-sha2")throw new Error("getBackupDecryptor: Unsupported algorithm ".concat(e.algorithm));var i=N.fromBase64(ve(r));if(!he(i,e))throw new Error("getBackupDecryptor: key backup on server does not match the decryption key");return t.backupManager.createBackupDecryptor(i)})()}importBackedUpRoomKeys(e,r,t){var i=this;return c(function*(){return yield i.backupManager.importBackedUpRoomKeys(e,r,t)})()}getVersion(){var e=Yr();return"Rust SDK ".concat(e.matrix_sdk_crypto," (").concat(e.git_sha,"), Vodozemac ").concat(e.vodozemac)}setDeviceIsolationMode(e){this.deviceIsolationMode=e}isEncryptionEnabledInRoom(e){var r=this;return c(function*(){var t=yield r.olmMachine.getRoomSettings(new R(e));return!!(t!=null&&t.algorithm)})()}getOwnDeviceKeys(){var e=this;return c(function*(){var r=e.olmMachine.identityKeys;return{ed25519:r.ed25519.toBase64(),curve25519:r.curve25519.toBase64()}})()}prepareToEncrypt(e){var r=this.roomEncryptors[e.roomId];r&&r.prepareForEncryption(this.globalBlacklistUnverifiedDevices,this.deviceIsolationMode)}forceDiscardSession(e){var r;return(r=this.roomEncryptors[e])===null||r===void 0?void 0:r.forceDiscardSession()}exportRoomKeys(){var e=this;return c(function*(){var r=yield e.olmMachine.exportRoomKeys(()=>!0);return JSON.parse(r)})()}exportRoomKeysAsJson(){var e=this;return c(function*(){return yield e.olmMachine.exportRoomKeys(()=>!0)})()}importRoomKeys(e,r){var t=this;return c(function*(){return yield t.backupManager.importRoomKeys(e,r)})()}importRoomKeysAsJson(e,r){var t=this;return c(function*(){return yield t.backupManager.importRoomKeysAsJson(e,r)})()}userHasCrossSigningKeys(){var e=arguments,r=this;return c(function*(){var t=e.length>0&&e[0]!==void 0?e[0]:r.userId,i=e.length>1&&e[1]!==void 0?e[1]:!1,n=yield r.olmMachine.trackedUsers(),a;for(var o of n)if(t===o.toString()){a=o;break}if(a!==void 0){if(t===r.userId){var u=r.olmMachine.queryKeysForUsers([a.clone()]);yield r.outgoingRequestProcessor.makeOutgoingRequest(u)}var d=yield r.olmMachine.getIdentity(a);return d==null||d.free(),d!==void 0}else if(i){var l,p=yield r.downloadDeviceList(new Set([t])),h=(l=p.master_keys)===null||l===void 0?void 0:l[t];return h?!!Object.values(h.keys)[0]:!1}else return!1})()}getUserDeviceInfo(e){var r=arguments,t=this;return c(function*(){var i=r.length>1&&r[1]!==void 0?r[1]:!1,n=new Map,a=yield t.getOlmMachineOrThrow().trackedUsers(),o=new Set;a.forEach(p=>o.add(p.toString()));var u=new Set;for(var d of e)o.has(d)?n.set(d,yield t.getUserDevices(d)):u.add(d);if(i&&u.size>=1){var l=yield t.downloadDeviceList(u);Object.entries(l.device_keys).forEach(p=>{var[h,f]=p;return n.set(h,mt(f))})}return n})()}getUserDevices(e){var r=this;return c(function*(){var t=new m(e),i=yield r.olmMachine.getUserDevices(t,1);try{var n=i.devices();try{return new Map(n.map(a=>[a.deviceId.toString(),ft(a,t)]))}finally{n.forEach(a=>a.free())}}finally{i.free()}})()}downloadDeviceList(e){var r=this;return c(function*(){var t={device_keys:{}};return e.forEach(i=>t.device_keys[i]=[]),yield r.http.authedRequest(k.Post,"/_matrix/client/v3/keys/query",void 0,t,{prefix:""})})()}getTrustCrossSignedDevices(){return this._trustCrossSignedDevices}setTrustCrossSignedDevices(e){this._trustCrossSignedDevices=e}setDeviceVerified(e,r){var t=arguments,i=this;return c(function*(){var n=t.length>2&&t[2]!==void 0?t[2]:!0,a=yield i.olmMachine.getDevice(new m(e),new O(r));if(!a)throw new Error("Unknown device ".concat(e,"|").concat(r));try{yield a.setLocalTrust(n?We.Verified:We.Unset)}finally{a.free()}})()}crossSignDevice(e){var r=this;return c(function*(){var t=yield r.olmMachine.getDevice(new m(r.userId),new O(e));if(!t)throw new Error("Unknown device ".concat(e));try{var i=yield t.verify();yield r.outgoingRequestProcessor.makeOutgoingRequest(i)}finally{t.free()}})()}getDeviceVerificationStatus(e,r){var t=this;return c(function*(){var i=yield t.olmMachine.getDevice(new m(e),new O(r));if(!i)return null;try{return new Ur({signedByOwner:i.isCrossSignedByOwner(),crossSigningVerified:i.isCrossSigningTrusted(),localVerified:i.isLocallyTrusted(),trustCrossSignedDevices:t._trustCrossSignedDevices})}finally{i.free()}})()}getUserVerificationStatus(e){var r=this;return c(function*(){var t=yield r.getOlmMachineOrThrow().getIdentity(new m(e));if(t===void 0)return new Ve(!1,!1,!1);var i=t.isVerified(),n=t.wasPreviouslyVerified(),a=t instanceof $r?t.identityNeedsUserApproval():!1;return t.free(),new Ve(i,n,!1,a)})()}pinCurrentUserIdentity(e){var r=this;return c(function*(){var t=yield r.getOlmMachineOrThrow().getIdentity(new m(e));if(t===void 0)throw new Error("Cannot pin identity of unknown user");if(t instanceof zr)throw new Error("Cannot pin identity of own user");yield t.pinCurrentMasterKey()})()}withdrawVerificationRequirement(e){var r=this;return c(function*(){var t=yield r.getOlmMachineOrThrow().getIdentity(new m(e));if(t===void 0)throw new Error("Cannot withdraw verification of unknown user");yield t.withdrawVerification()})()}isCrossSigningReady(){var e=this;return c(function*(){var{privateKeysInSecretStorage:r,privateKeysCachedLocally:t}=yield e.getCrossSigningStatus(),i=!!t.masterKey&&!!t.selfSigningKey&&!!t.userSigningKey,n=yield e.getOwnIdentity();return!!(n!=null&&n.isVerified())&&(i||r)})()}getCrossSigningKeyId(){var e=arguments,r=this;return c(function*(){var t=e.length>0&&e[0]!==void 0?e[0]:z.Master,i=yield r.olmMachine.getIdentity(new m(r.userId));if(!i)return null;try{var n=yield r.olmMachine.crossSigningStatus(),a=n.hasMaster&&n.hasUserSigning&&n.hasSelfSigning;if(!a||!i.isVerified())return null;var o;switch(t){case z.Master:o=i.masterKey;break;case z.SelfSigning:o=i.selfSigningKey;break;case z.UserSigning:o=i.userSigningKey;break;default:return null}var u=JSON.parse(o);return Object.values(u.keys)[0]}finally{i.free()}})()}bootstrapCrossSigning(e){var r=this;return c(function*(){yield r.crossSigningIdentity.bootstrapCrossSigning(e)})()}isSecretStorageReady(){var e=this;return c(function*(){var r=["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"],t=(yield e.backupManager.getActiveBackupVersion())!=null;return t&&r.push("m.megolm_backup.v1"),Sr(e.secretStorage,r)})()}bootstrapSecretStorage(){var e=arguments,r=this;return c(function*(){var{createSecretStorageKey:t,setupNewSecretStorage:i,setupNewKeyBackup:n}=e.length>0&&e[0]!==void 0?e[0]:{},a=i||!(yield r.secretStorageHasAESKey());if(a){if(!t)throw new Error("unable to create a new secret storage key, createSecretStorageKey is not set");r.logger.info("bootstrapSecretStorage: creating new secret storage key");var o=yield t();if(!o)throw new Error("createSecretStorageKey() callback did not return a secret storage key");yield r.addSecretStorageKeyToSecretStorage(o)}var u=yield r.olmMachine.exportCrossSigningKeys(),d=u&&u.masterKey!==void 0&&u.self_signing_key!==void 0&&u.userSigningKey!==void 0;d&&(a||!(yield Ze(r.secretStorage)))&&(r.logger.info("bootstrapSecretStorage: cross-signing keys not yet exported; doing so now."),yield r.secretStorage.store("m.cross_signing.master",u.masterKey),yield r.secretStorage.store("m.cross_signing.user_signing",u.userSigningKey),yield r.secretStorage.store("m.cross_signing.self_signing",u.self_signing_key)),n?yield r.resetKeyBackup():yield r.saveBackupKeyToStorage()})()}saveBackupKeyToStorage(){var e=this;return c(function*(){var r=yield e.backupManager.getServerBackupInfo();if(!r||!r.version){g.info("Not saving backup key to secret storage: no backup info");return}var t=yield e.olmMachine.getBackupKeys();if(!t.decryptionKey){g.info("Not saving backup key to secret storage: no backup key");return}if(!he(t.decryptionKey,r)){g.info("Not saving backup key to secret storage: decryption key does not match backup info");return}var i=t.decryptionKey.toBase64();yield e.secretStorage.store("m.megolm_backup.v1",i)})()}addSecretStorageKeyToSecretStorage(e){var r=this;return c(function*(){var t,i,n,a,o=yield r.secretStorage.addKey(Ne,{passphrase:(t=e.keyInfo)===null||t===void 0?void 0:t.passphrase,name:(i=e.keyInfo)===null||i===void 0?void 0:i.name,key:e.privateKey});yield r.secretStorage.setDefaultKeyId(o.keyId),(n=(a=r.cryptoCallbacks).cacheSecretStorageKey)===null||n===void 0||n.call(a,o.keyId,o.keyInfo,e.privateKey)})()}secretStorageHasAESKey(){var e=this;return c(function*(){var r=yield e.secretStorage.getKey();if(!r)return!1;var[,t]=r;return t.algorithm===Ne})()}getCrossSigningStatus(){var e=this;return c(function*(){var r=yield e.getOlmMachineOrThrow().getIdentity(new m(e.userId)),t=!!(r!=null&&r.masterKey)&&!!(r!=null&&r.selfSigningKey)&&!!(r!=null&&r.userSigningKey);r==null||r.free();var i=yield Ze(e.secretStorage),n=yield e.getOlmMachineOrThrow().crossSigningStatus();return{publicKeysOnDevice:t,privateKeysInSecretStorage:i,privateKeysCachedLocally:{masterKey:!!(n!=null&&n.hasMaster),userSigningKey:!!(n!=null&&n.hasUserSigning),selfSigningKey:!!(n!=null&&n.hasSelfSigning)}}})()}createRecoveryKeyFromPassphrase(e){var r=this;return c(function*(){if(e){var t=xe(32),i=yield kr(e,t,r.RECOVERY_KEY_DERIVATION_ITERATIONS);return{keyInfo:{passphrase:{algorithm:"m.pbkdf2",iterations:r.RECOVERY_KEY_DERIVATION_ITERATIONS,salt:t}},privateKey:i,encodedPrivateKey:Ye(i)}}else{var n=new Uint8Array(32);return globalThis.crypto.getRandomValues(n),{privateKey:n,encodedPrivateKey:Ye(n)}}})()}getEncryptionInfoForEvent(e){var r=this;return c(function*(){return r.eventDecryptor.getEncryptionInfoForEvent(e)})()}getVerificationRequestsToDeviceInProgress(e){var r=this.olmMachine.getVerificationRequests(new m(e));return r.filter(t=>t.roomId===void 0).map(t=>this.makeVerificationRequest(t))}findVerificationRequestDMInProgress(e,r){if(!r)throw new Error("missing userId");var t=this.olmMachine.getVerificationRequests(new m(r)),i=t.find(n=>{var a;return((a=n.roomId)===null||a===void 0?void 0:a.toString())===e});if(i)return this.makeVerificationRequest(i)}requestVerificationDM(e,r){var t=this;return c(function*(){var i=yield t.olmMachine.getIdentity(new m(e));if(!i)throw new Error("unknown userId ".concat(e));try{var n=t._supportedVerificationMethods.map(d=>ne(d)),a=yield i.verificationRequestContent(n),o=yield t.sendVerificationRequestContent(r,a),u=yield i.requestVerification(new R(r),new Zr(o),n);return t.makeVerificationRequest(u)}finally{i.free()}})()}sendVerificationRequestContent(e,r){var t=this;return c(function*(){var i=xe(32),{event_id:n}=yield t.http.authedRequest(k.Put,"/_matrix/client/v3/rooms/".concat(encodeURIComponent(e),"/send/m.room.message/").concat(encodeURIComponent(i)),void 0,r,{prefix:""});return n})()}setSupportedVerificationMethods(e){this._supportedVerificationMethods=e??or}requestOwnUserVerification(){var e=this;return c(function*(){var r=yield e.olmMachine.getIdentity(new m(e.userId));if(r===void 0)throw new Error("cannot request verification for this device when there is no existing cross-signing key");try{var[t,i]=yield r.requestVerification(e._supportedVerificationMethods.map(ne));return yield e.outgoingRequestProcessor.makeOutgoingRequest(i),e.makeVerificationRequest(t)}finally{r.free()}})()}requestDeviceVerification(e,r){var t=this;return c(function*(){var i=yield t.olmMachine.getDevice(new m(e),new O(r));if(!i)throw new Error("Not a known device");try{var[n,a]=i.requestVerification(t._supportedVerificationMethods.map(ne));return yield t.outgoingRequestProcessor.makeOutgoingRequest(a),t.makeVerificationRequest(n)}finally{i.free()}})()}getSessionBackupPrivateKey(){var e=this;return c(function*(){var r=yield e.olmMachine.getBackupKeys();return r.decryptionKey?pe(r.decryptionKey.toBase64()):null})()}storeSessionBackupPrivateKey(e,r){var t=this;return c(function*(){var i=ve(e);if(!r)throw new Error("storeSessionBackupPrivateKey: version is required");yield t.backupManager.saveBackupDecryptionKey(N.fromBase64(i),r)})()}loadSessionBackupPrivateKeyFromSecretStorage(){var e=this;return c(function*(){var r=yield e.secretStorage.get("m.megolm_backup.v1");if(!r)throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: missing decryption key in secret storage");var t=yield e.backupManager.getServerBackupInfo();if(!t||!t.version)throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: unable to get backup version");var i=N.fromBase64(r);if(!he(i,t))throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: decryption key does not match backup info");yield e.backupManager.saveBackupDecryptionKey(i,t.version)})()}getActiveSessionBackupVersion(){var e=this;return c(function*(){return yield e.backupManager.getActiveBackupVersion()})()}getKeyBackupInfo(){var e=this;return c(function*(){return(yield e.backupManager.getServerBackupInfo())||null})()}isKeyBackupTrusted(e){var r=this;return c(function*(){return yield r.backupManager.isKeyBackupTrusted(e)})()}checkKeyBackupAndEnable(){var e=this;return c(function*(){return yield e.backupManager.checkKeyBackupAndEnable(!0)})()}deleteKeyBackupVersion(e){var r=this;return c(function*(){yield r.backupManager.deleteKeyBackupVersion(e)})()}resetKeyBackup(){var e=this;return c(function*(){var r=yield e.backupManager.setupKeyBackup(t=>e.signObject(t));(yield e.secretStorageHasAESKey())&&(yield e.secretStorage.store("m.megolm_backup.v1",r.decryptionKey.toBase64())),e.checkKeyBackupAndEnable()})()}disableKeyStorage(){var e=this;return c(function*(){var r=yield e.getKeyBackupInfo();r!=null&&r.version?yield e.deleteKeyBackupVersion(r.version):g.error("Can't delete key backup version: no version available"),yield e.deleteSecretStorage(),yield e.dehydratedDeviceManager.delete()})()}signObject(e){var r=this;return c(function*(){var t=new Map(Object.entries(e.signatures||{})),i=e.unsigned;delete e.signatures,delete e.unsigned;var n=t.get(r.userId)||{},a=ut.stringify(e),o=yield r.olmMachine.sign(a),u=JSON.parse(o.asJSON());t.set(r.userId,sr(sr({},n),u[r.userId])),i!==void 0&&(e.unsigned=i),e.signatures=Object.fromEntries(t.entries())})()}restoreKeyBackupWithPassphrase(e,r){var t=this;return c(function*(){var i=yield t.backupManager.getServerBackupInfo();if(!(i!=null&&i.version))throw new Error("No backup info available");var n=yield Mt(i.auth_data,e);return yield t.storeSessionBackupPrivateKey(n,i.version),t.restoreKeyBackup(r)})()}restoreKeyBackup(e){var r=this;return c(function*(){var t=yield r.olmMachine.getBackupKeys(),{decryptionKey:i,backupVersion:n}=t;if(!i||!n)throw new Error("No decryption key found in crypto store");var a=pe(i.toBase64()),o=yield r.backupManager.requestKeyBackupVersion(n);if(!o)throw new Error("Backup version to restore ".concat(n," not found on server"));var u=yield r.getBackupDecryptor(o,a);try{var d;return e==null||(d=e.progressCallback)===null||d===void 0||d.call(e,{stage:L.Fetch}),yield r.backupManager.restoreKeyBackup(n,u,e)}finally{u.free()}})()}isDehydrationSupported(){var e=this;return c(function*(){return yield e.dehydratedDeviceManager.isSupported()})()}startDehydration(){var e=arguments,r=this;return c(function*(){var t=e.length>0&&e[0]!==void 0?e[0]:{};if(!(yield r.isCrossSigningReady())||!(yield r.isSecretStorageReady()))throw new Error("Device dehydration requires cross-signing and secret storage to be set up");return yield r.dehydratedDeviceManager.start(t||{})})()}importSecretsBundle(e){var r=this;return c(function*(){var t=Xr.from_json(e);yield r.getOlmMachineOrThrow().importSecretsBundle(t)})()}exportSecretsBundle(){var e=this;return c(function*(){var r=yield e.getOlmMachineOrThrow().exportSecretsBundle(),t=r.to_json();return r.free(),t})()}encryptToDeviceMessages(e,r,t){var i=this;return c(function*(){var n=new ur(i.logger,"encryptToDeviceMessages"),a=new Set(r.map(u=>{var{userId:d}=u;return d}));yield i.keyClaimManager.ensureSessionsForUsers(n,Array.from(a).map(u=>new m(u)));var o={batch:[],eventType:w.RoomMessageEncrypted};return yield Promise.all(r.map(function(){var u=c(function*(d){var{userId:l,deviceId:p}=d,h=yield i.olmMachine.getDevice(new m(l),new O(p));if(h){var f=JSON.parse(yield h.encryptToDeviceEvent(e,t));o.batch.push({deviceId:p,userId:l,payload:f})}else i.logger.warn("encryptToDeviceMessages: unknown device ".concat(l,":").concat(p))});return function(d){return u.apply(this,arguments)}}())),o})()}resetEncryption(e){var r=this;return c(function*(){r.logger.debug("resetEncryption: resetting encryption"),r.dehydratedDeviceManager.delete(),yield r.backupManager.deleteAllKeyBackupVersions(),yield r.deleteSecretStorage(),yield r.crossSigningIdentity.bootstrapCrossSigning({setupNewCrossSigning:!0,authUploadDeviceSigningKeys:e}),yield r.resetKeyBackup(),r.logger.debug("resetEncryption: ended")})()}deleteSecretStorage(){var e=this;return c(function*(){yield e.secretStorage.store("m.cross_signing.master",null),yield e.secretStorage.store("m.cross_signing.self_signing",null),yield e.secretStorage.store("m.cross_signing.user_signing",null),yield e.secretStorage.store("m.megolm_backup.v1",null);var r=yield e.secretStorage.getDefaultKeyId();r&&(yield e.secretStorage.store("m.secret_storage.key.".concat(r),null)),yield e.secretStorage.setDefaultKeyId(null)})()}receiveSyncChanges(e){var r=this;return c(function*(){var{events:t,oneTimeKeysCounts:i=new Map,unusedFallbackKeys:n,devices:a=new Je}=e,o=yield M(g,"receiveSyncChanges",c(function*(){return yield r.olmMachine.receiveSyncChanges(t?JSON.stringify(t):"[]",a,i,n)}));return JSON.parse(o)})()}preprocessToDeviceMessages(e){var r=this;return c(function*(){var t=yield r.receiveSyncChanges({events:e});for(var i of t)if(i.type===w.KeyVerificationRequest){var n=i.sender,a=i.content.transaction_id;a&&n&&r.onIncomingKeyVerificationRequest(n,a)}return t})()}processKeyCounts(e,r){var t=this;return c(function*(){var i=e&&new Map(Object.entries(e)),n=r&&new Set(r);(i!==void 0||n!==void 0)&&(yield t.receiveSyncChanges({oneTimeKeysCounts:i,unusedFallbackKeys:n}))})()}processDeviceLists(e){var r=this;return c(function*(){var t,i,n=new Je((t=e.changed)===null||t===void 0?void 0:t.map(a=>new m(a)),(i=e.left)===null||i===void 0?void 0:i.map(a=>new m(a)));yield r.receiveSyncChanges({devices:n})})()}onCryptoEvent(e,r){var t=this;return c(function*(){var i=r.getContent(),n=new hr;if(i.algorithm==="m.megolm.v1.aes-sha2")n.algorithm=W.MegolmV1AesSha2;else{t.logger.warn("Room ".concat(e.roomId,": ignoring crypto event with invalid algorithm ").concat(i.algorithm));return}try{n.sessionRotationPeriodMs=i.rotation_period_ms,n.sessionRotationPeriodMessages=i.rotation_period_msgs,yield t.olmMachine.setRoomSettings(new R(e.roomId),n)}catch(o){t.logger.warn("Room ".concat(e.roomId,": ignoring crypto event which caused error: ").concat(o));return}var a=t.roomEncryptors[e.roomId];a?a.onCryptoEvent(i):t.roomEncryptors[e.roomId]=new dt(t.olmMachine,t.keyClaimManager,t.outgoingRequestsManager,e,i)})()}onSyncCompleted(e){this.outgoingRequestsManager.doProcessOutgoingRequests().catch(r=>{this.logger.warn("onSyncCompleted: Error processing outgoing requests",r)})}markAllTrackedUsersAsDirty(){var e=this;return c(function*(){yield e.olmMachine.markAllTrackedUsersAsDirty()})()}onIncomingKeyVerificationRequest(e,r){var t=this.olmMachine.getVerificationRequest(new m(e),r);t?this.emit(v.VerificationRequestReceived,this.makeVerificationRequest(t)):this.logger.info("Ignoring just-received verification request ".concat(r," which did not start a rust-side verification"))}makeVerificationRequest(e){return new _t(this.logger,this.olmMachine,e,this.outgoingRequestProcessor,this._supportedVerificationMethods)}onRoomMembership(e,r,t){var i=this.roomEncryptors[e.getRoomId()];i&&i.onRoomMembership(r)}onRoomKeysUpdated(e){var r=this;return c(function*(){for(var t of e)r.onRoomKeyUpdated(t);r.backupManager.maybeUploadKey()})()}onRoomKeyUpdated(e){var r=this;if(!this.stopped){this.logger.debug("Got update for session ".concat(e.sessionId," from sender ").concat(e.senderKey.toBase64()," in ").concat(e.roomId.toString()));var t=this.eventDecryptor.getEventsPendingRoomKey(e.roomId.toString(),e.sessionId);if(t.length!==0){this.logger.debug("Retrying decryption on events:",t.map(a=>"".concat(a.getId())));var i=function(o){o.attemptDecryption(r,{isRetry:!0}).catch(u=>{r.logger.info("Still unable to decrypt event ".concat(o.getId()," after receiving key"))})};for(var n of t)i(n)}}}onRoomKeysWithheld(e){var r=this;return c(function*(){for(var t of e){r.logger.debug("Got withheld message for session ".concat(t.sessionId," in ").concat(t.roomId.toString()));var i=r.eventDecryptor.getEventsPendingRoomKey(t.roomId.toString(),t.sessionId);if(i.length===0)return;r.logger.debug("Retrying decryption on events:",i.map(a=>"".concat(a.getId())));for(var n of i)n.attemptDecryption(r,{isRetry:!0}).catch(a=>{})}})()}onUserIdentityUpdated(e){var r=this;return c(function*(){var t=yield r.getUserVerificationStatus(e.toString());r.emit(v.UserTrustStatusChanged,e.toString(),t),e.toString()===r.userId&&(r.emit(v.KeysChanged,{}),yield r.checkKeyBackupAndEnable())})()}onDevicesUpdated(e){var r=this;return c(function*(){r.emit(v.WillUpdateDevices,e,!1),r.emit(v.DevicesUpdated,e,!1)})()}handleSecretReceived(e,r){var t=this;return c(function*(){return t.logger.debug("onReceiveSecret: Received secret ".concat(e)),e==="m.megolm_backup.v1"?yield t.backupManager.handleBackupSecretReceived(r):!1})()}checkSecrets(e){var r=this;return c(function*(){var t=yield r.olmMachine.getSecretsFromInbox(e);for(var i of t)if(yield r.handleSecretReceived(e,i))break;yield r.olmMachine.deleteSecretsFromInbox(e)})()}onLiveEventFromSync(e){var r=this;return c(function*(){if(!(e.isState()||e.getUnsigned().transaction_id)){var t=function(){var o=c(function*(u){bt(e)&&(yield r.onKeyVerificationEvent(u))});return function(d){return o.apply(this,arguments)}}();if(e.isDecryptionFailure()||e.isEncrypted()){var i=3e5,n=setTimeout(()=>e.off(ue.Decrypted,a),i),a=(o,u)=>{u||(clearTimeout(n),e.off(ue.Decrypted,a),t(o))};e.on(ue.Decrypted,a)}else yield t(e)}})()}onKeyVerificationEvent(e){var r=this;return c(function*(){var t=e.getRoomId();if(!t)throw new Error("missing roomId in the event");r.logger.debug("Incoming verification event ".concat(e.getId()," type ").concat(e.getType()," from ").concat(e.getSender())),yield r.olmMachine.receiveVerificationEvent(JSON.stringify({event_id:e.getId(),type:e.getType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getContent(),origin_server_ts:e.getTs()}),new R(t)),e.getType()===w.RoomMessage&&e.getContent().msgtype===gr.KeyVerificationRequest&&r.onIncomingKeyVerificationRequest(e.getSender(),e.getId()),r.outgoingRequestsManager.doProcessOutgoingRequests().catch(i=>{r.logger.warn("onKeyVerificationRequest: Error processing outgoing requests",i)})})()}getOwnIdentity(){var e=this;return c(function*(){return yield e.olmMachine.getIdentity(new m(e.userId))})()}}class It{constructor(e,r,t){this.logger=e,this.olmMachine=r,this.perSessionBackupDownloader=t,y(this,"eventsPendingKey",new Ae(()=>new Ae(()=>new Set)))}attemptEventDecryption(e,r){var t=this;return c(function*(){t.addEventToPendingList(e);var i;switch(r.kind){case oe.AllDevicesIsolationMode:i=He.Untrusted;break;case oe.OnlySignedDevicesIsolationMode:i=He.CrossSignedOrLegacy;break}try{var n=yield t.olmMachine.decryptRoomEvent(ar(e),new R(e.getRoomId()),new et(i));return t.removeEventFromPendingList(e),{clearEvent:JSON.parse(n.event),claimedEd25519Key:n.senderClaimedEd25519Key,senderCurve25519Key:n.senderCurve25519Key,forwardingCurve25519KeyChain:n.forwardingCurve25519KeyChain}}catch(a){if(a instanceof rt)t.onMegolmDecryptionError(e,a,yield t.perSessionBackupDownloader.getServerBackupInfo());else throw new b(_.UNKNOWN_ERROR,"Unknown error")}})()}onMegolmDecryptionError(e,r,t){var i=e.getWireContent(),n={sender_key:i.sender_key,session_id:i.session_id};if(r.code===q.MissingRoomKey||r.code===q.UnknownMessageIndex){this.perSessionBackupDownloader.onDecryptionKeyMissingError(e.getRoomId(),i.session_id);var a=e.getMembershipAtEvent();if(a&&a!==se.Join&&a!==se.Invite)throw new b(_.HISTORICAL_MESSAGE_USER_NOT_JOINED,"This message was sent when we were not a member of the room.",n);if(e.getTs()<=this.olmMachine.deviceCreationTimeMs)throw t===null?new b(_.HISTORICAL_MESSAGE_NO_KEY_BACKUP,"This message was sent before this device logged in, and there is no key backup on the server.",n):this.perSessionBackupDownloader.isKeyBackupDownloadConfigured()?new b(_.HISTORICAL_MESSAGE_WORKING_BACKUP,"This message was sent before this device logged in. Key backup is working, but we still do not (yet) have the key.",n):new b(_.HISTORICAL_MESSAGE_BACKUP_UNCONFIGURED,"This message was sent before this device logged in, and key backup is not working.",n)}if(r.maybe_withheld){var o=r.maybe_withheld==="The sender has disabled encrypting to unverified devices."?_.MEGOLM_KEY_WITHHELD_FOR_UNVERIFIED_DEVICE:_.MEGOLM_KEY_WITHHELD;throw new b(o,r.maybe_withheld,n)}switch(r.code){case q.MissingRoomKey:throw new b(_.MEGOLM_UNKNOWN_INBOUND_SESSION_ID,"The sender's device has not sent us the keys for this message.",n);case q.UnknownMessageIndex:throw new b(_.OLM_UNKNOWN_MESSAGE_INDEX,"The sender's device has not sent us the keys for this message at this index.",n);case q.SenderIdentityVerificationViolation:throw this.removeEventFromPendingList(e),new b(_.SENDER_IDENTITY_PREVIOUSLY_VERIFIED,"The sender identity is unverified, but was previously verified.");case q.UnknownSenderDevice:throw this.removeEventFromPendingList(e),new b(_.UNKNOWN_SENDER_DEVICE,"The sender device is not known.");case q.UnsignedSenderDevice:throw this.removeEventFromPendingList(e),new b(_.UNSIGNED_SENDER_DEVICE,"The sender identity is not cross-signed.");default:throw new b(_.UNKNOWN_ERROR,r.description,n)}}getEncryptionInfoForEvent(e){var r=this;return c(function*(){if(!e.getClearContent()||e.isDecryptionFailure())return null;if(e.status!==null)return{shieldColour:ie.NONE,shieldReason:null};var t=yield r.olmMachine.getRoomEventEncryptionInfo(ar(e),new R(e.getRoomId()));return Dt(r.logger,t)})()}getEventsPendingRoomKey(e,r){var t=this.eventsPendingKey.get(e);if(!t)return[];var i=t.get(r);return i?[...i]:[]}addEventToPendingList(e){var r=e.getRoomId();if(r){var t=this.eventsPendingKey.getOrCreate(r),i=t.getOrCreate(e.getWireContent().session_id);i.add(e)}}removeEventFromPendingList(e){var r=e.getRoomId();if(r){var t=this.eventsPendingKey.getOrCreate(r);if(t){var i=t.get(e.getWireContent().session_id);i&&(i.delete(e),i.size===0&&(t.delete(e.getWireContent().session_id),t.size===0&&this.eventsPendingKey.delete(r)))}}}}function ar(s){return JSON.stringify({event_id:s.getId(),type:s.getWireType(),sender:s.getSender(),state_key:s.getStateKey(),content:s.getWireContent(),origin_server_ts:s.getTs()})}function Dt(s,e){if(e===void 0)return null;var r=e.shieldState(!1),t;switch(r.color){case Qe.Grey:t=ie.GREY;break;case Qe.None:t=ie.NONE;break;default:t=ie.RED}var i;switch(r.code){case void 0:case null:i=null;break;case V.AuthenticityNotGuaranteed:i=P.AUTHENTICITY_NOT_GUARANTEED;break;case V.UnknownDevice:i=P.UNKNOWN_DEVICE;break;case V.UnsignedDevice:i=P.UNSIGNED_DEVICE;break;case V.UnverifiedIdentity:i=P.UNVERIFIED_IDENTITY;break;case V.SentInClear:i=P.SENT_IN_CLEAR;break;case V.VerificationViolation:i=P.VERIFICATION_VIOLATION;break}return{shieldColour:t,shieldReason:i}}function Ot(s){return _e.apply(this,arguments)}function _e(){return _e=c(function*(s){var e,{logger:r,legacyStore:t}=s;if(yield pr(),new vr(fr.Debug).turnOn(),!(yield t.containsData()))return;yield t.startup();var i=null;if(yield t.doTxn("readonly",[H.STORE_ACCOUNT],h=>{t.getAccount(h,f=>{i=f})}),!i){r.debug("Legacy crypto store is not set up (no account found). Not migrating.");return}var n=yield t.getMigrationState();if(n>=K.MEGOLM_SESSIONS_MIGRATED)return;var a=yield qt(r,t),o=yield Tt(r,t),u=1+a+o;r.info("Migrating data from legacy crypto store. ".concat(a," olm sessions and ").concat(o," megolm sessions to migrate."));var d=0;function l(h){var f;d+=h,(f=s.legacyMigrationProgressListener)===null||f===void 0||f.call(s,d,u)}l(0);var p=new TextEncoder().encode(s.legacyPickleKey);n===K.NOT_STARTED&&(r.info("Migrating data from legacy crypto store. Step 1: base data"),yield Bt(s.http,s.userId,s.deviceId,t,p,s.storeHandle,r),n=K.INITIAL_DATA_MIGRATED,yield t.setMigrationState(n)),l(1),n===K.INITIAL_DATA_MIGRATED&&(r.info("Migrating data from legacy crypto store. Step 2: olm sessions (".concat(a," sessions to migrate).")),yield Pt(r,t,p,s.storeHandle,l),n=K.OLM_SESSIONS_MIGRATED,yield t.setMigrationState(n)),n===K.OLM_SESSIONS_MIGRATED&&(r.info("Migrating data from legacy crypto store. Step 3: megolm sessions (".concat(o," sessions to migrate).")),yield Ut(r,t,p,s.storeHandle,l),n=K.MEGOLM_SESSIONS_MIGRATED,yield t.setMigrationState(n)),(e=s.legacyMigrationProgressListener)===null||e===void 0||e.call(s,-1,-1),r.info("Migration from legacy crypto store complete")}),_e.apply(this,arguments)}function Bt(s,e,r,t,i,n,a){return be.apply(this,arguments)}function be(){return be=c(function*(s,e,r,t,i,n,a){var o=new tt;o.userId=new m(e),o.deviceId=new O(r),yield t.doTxn("readonly",[H.STORE_ACCOUNT],I=>t.getAccount(I,x=>{o.pickledAccount=x??""}));var u=yield re(t,i,"m.megolm_backup.v1");if(u){for(var d=!1,l=null;!d;)try{l=yield wr(s),d=!0}catch(I){a.info("Failed to get backup version during migration, retrying in 2 seconds",I),yield T(2e3)}if(l&&l.algorithm=="m.megolm_backup.v1.curve25519-aes-sha2")try{var p,h=N.fromBase64(u),f=(p=l.auth_data)===null||p===void 0?void 0:p.public_key,C=h.megolmV1PublicKey.publicKeyBase64==f;C?(o.backupVersion=l.version,o.backupRecoveryKey=u):a.debug("The backup key to migrate does not match the active backup version","Cached pub key: ".concat(h.megolmV1PublicKey.publicKeyBase64),"Active pub key: ".concat(f))}catch(I){a.warn("Failed to check if the backup key to migrate matches the active backup version",I)}}o.privateCrossSigningMasterKey=yield re(t,i,"master"),o.privateCrossSigningSelfSigningKey=yield re(t,i,"self_signing"),o.privateCrossSigningUserSigningKey=yield re(t,i,"user_signing"),yield qe.migrateBaseData(o,i,n)}),be.apply(this,arguments)}function qt(s,e){return we.apply(this,arguments)}function we(){return we=c(function*(s,e){s.debug("Counting olm sessions to be migrated");var r;return yield e.doTxn("readonly",[H.STORE_SESSIONS],t=>e.countEndToEndSessions(t,i=>r=i)),r}),we.apply(this,arguments)}function Tt(s,e){return Re.apply(this,arguments)}function Re(){return Re=c(function*(s,e){return s.debug("Counting megolm sessions to be migrated"),yield e.countEndToEndInboundGroupSessions()}),Re.apply(this,arguments)}function Pt(s,e,r,t,i){return Ke.apply(this,arguments)}function Ke(){return Ke=c(function*(s,e,r,t,i){for(;;){var n=yield e.getEndToEndSessionsBatch();if(n===null)return;s.debug("Migrating batch of ".concat(n.length," olm sessions"));var a=[];for(var o of n){var u=new it;u.senderKey=o.deviceKey,u.pickle=o.session,u.lastUseTime=u.creationTime=new Date(o.lastReceivedMessageTs),a.push(u)}yield qe.migrateOlmSessions(a,r,t),yield e.deleteEndToEndSessionsBatch(n),i(n.length)}}),Ke.apply(this,arguments)}function Ut(s,e,r,t,i){return Ee.apply(this,arguments)}function Ee(){return Ee=c(function*(s,e,r,t,i){for(;;){var n=yield e.getEndToEndInboundGroupSessionsBatch();if(n===null)return;s.debug("Migrating batch of ".concat(n.length," megolm sessions"));var a=[];for(var o of n){var u,d=o.sessionData,l=new nt;l.pickle=d.session,l.roomId=new R(d.room_id),l.senderKey=o.senderKey,l.senderSigningKey=(u=d.keysClaimed)===null||u===void 0?void 0:u.ed25519,l.backedUp=!o.needsBackup,l.imported=d.untrusted===!0,a.push(l)}yield qe.migrateMegolmSessions(a,r,t),yield e.deleteEndToEndInboundGroupSessionsBatch(n),i(n.length)}}),Ee.apply(this,arguments)}function Vt(s){return Me.apply(this,arguments)}function Me(){return Me=c(function*(s){var{logger:e,legacyStore:r,olmMachine:t}=s;if(yield r.containsData()){var i=yield r.getMigrationState();if(!(i>=K.ROOM_SETTINGS_MIGRATED)){var n={};yield r.doTxn("readwrite",[H.STORE_ROOMS],d=>{r.getEndToEndRooms(d,l=>{n=l})}),e.debug("Migrating ".concat(Object.keys(n).length," sets of room settings"));for(var[a,o]of Object.entries(n))try{var u=new hr;if(o.algorithm!=="m.megolm.v1.aes-sha2"){e.warn("Room ".concat(a,": ignoring room with invalid algorithm ").concat(o.algorithm));continue}u.algorithm=W.MegolmV1AesSha2,u.sessionRotationPeriodMs=o.rotation_period_ms,u.sessionRotationPeriodMessages=o.rotation_period_msgs,yield t.setRoomSettings(new R(a),u)}catch(d){e.warn("Room ".concat(a,": ignoring settings ").concat(JSON.stringify(o)," which caused error ").concat(d))}e.debug("Completed room settings migration"),yield r.setMigrationState(K.ROOM_SETTINGS_MIGRATED)}}}),Me.apply(this,arguments)}function re(s,e,r){return Ce.apply(this,arguments)}function Ce(){return Ce=c(function*(s,e,r){var t=yield new Promise(i=>{s.doTxn("readonly",[H.STORE_ACCOUNT],n=>{s.getSecretStorePrivateKey(n,i,r)})});return t&&t.ciphertext&&t.iv&&t.mac?yield Vr(t,e,r):t instanceof Uint8Array?ve(t):void 0}),Ce.apply(this,arguments)}function Nt(s){return Ie.apply(this,arguments)}function Ie(){return Ie=c(function*(s){var{legacyCryptoStore:e,rustCrypto:r,logger:t}=s,i=yield r.getOwnIdentity();if(i&&!i.isVerified()){var n=yield xt(e);if(n){var a=JSON.parse(i.masterKey);if(!a.keys||Object.keys(a.keys).length===0){t.error("Post Migration | Unexpected error: no master key in the rust session.");return}var o=Object.values(a.keys)[0];o&&o==n&&(t.info("Post Migration: Migrating legacy trusted MSK: ".concat(n," to locally verified.")),yield i.verify())}}}),Ie.apply(this,arguments)}function xt(s){return De.apply(this,arguments)}function De(){return De=c(function*(s){var e=null;return yield s.doTxn("readonly","account",r=>{s.getCrossSigningKeys(r,t=>{var i=t==null?void 0:t.master;i&&Object.keys(i.keys).length!=0&&(e=Object.values(i.keys)[0])})}),e}),De.apply(this,arguments)}function cr(s,e){var r=Object.keys(s);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(s);e&&(t=t.filter(function(i){return Object.getOwnPropertyDescriptor(s,i).enumerable})),r.push.apply(r,t)}return r}function At(s){for(var e=1;e<arguments.length;e++){var r=arguments[e]!=null?arguments[e]:{};e%2?cr(Object(r),!0).forEach(function(t){y(s,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(s,Object.getOwnPropertyDescriptors(r)):cr(Object(r)).forEach(function(t){Object.defineProperty(s,t,Object.getOwnPropertyDescriptor(r,t))})}return s}function Gt(s){return Oe.apply(this,arguments)}function Oe(){return Oe=c(function*(s){var{logger:e}=s;e.debug("Initialising Rust crypto-sdk WASM artifact"),yield pr(),new vr(fr.Debug).turnOn(),e.debug("Opening Rust CryptoStore");var r;s.storePrefix?s.storeKey?r=yield de.openWithKey(s.storePrefix,s.storeKey):r=yield de.open(s.storePrefix,s.storePassphrase):r=yield de.open(),s.legacyCryptoStore&&(yield Ot(At({legacyStore:s.legacyCryptoStore,storeHandle:r},s)));var t=yield Lt(e,s.http,s.userId,s.deviceId,s.secretStorage,s.cryptoCallbacks,r,s.legacyCryptoStore);return r.free(),e.debug("Completed rust crypto-sdk setup"),t}),Oe.apply(this,arguments)}function Lt(s,e,r,t,i,n,a,o){return Be.apply(this,arguments)}function Be(){return Be=c(function*(s,e,r,t,i,n,a,o){s.debug("Init OlmMachine");var u=yield st.initFromStore(new m(r),new O(t),a);o&&(yield Vt({logger:s,legacyStore:o,olmMachine:u})),u.roomKeyRequestsEnabled=!1;var d=new Ct(s,u,e,r,t,i,n);if(yield u.registerRoomKeyUpdatedCallback(h=>d.onRoomKeysUpdated(h)),yield u.registerRoomKeysWithheldCallback(h=>d.onRoomKeysWithheld(h)),yield u.registerUserIdentityUpdatedCallback(h=>d.onUserIdentityUpdated(h)),yield u.registerDevicesUpdatedCallback(h=>d.onDevicesUpdated(h)),d.checkSecrets("m.megolm_backup.v1"),yield u.registerReceiveSecretCallback((h,f)=>d.checkSecrets(h)),yield u.outgoingRequests(),o&&(yield o.containsData())){var l=yield o.getMigrationState();if(l<K.INITIAL_OWN_KEY_QUERY_DONE){s.debug("Performing initial key query after migration");for(var p=!1;!p;)try{yield d.userHasCrossSigningKeys(r),p=!0}catch(h){s.error("Failed to check for cross-signing keys after migration, retrying",h)}yield Nt({legacyCryptoStore:o,rustCrypto:d,logger:s}),yield o.setMigrationState(K.INITIAL_OWN_KEY_QUERY_DONE)}}return d}),Be.apply(this,arguments)}export{Gt as initRustCrypto};
//# sourceMappingURL=index-CoTybJrM.js.map
